{
	"type": "xypdf",
	"description": "xyOps Portable Data Object",
	"version": "1.0",
	"xyops": "1.0.0",
	"items": [
		{
			"type": "plugin",
			"data": {
				"id": "net1network0001",
				"title": "Network Diagnostic",
				"enabled": true,
				"type": "event",
				"command": "pwsh",
				"script": "#requires -Version 7.0\n# Copyright (c) 2026 Tim Alderweireldt. All rights reserved.\n<#!\nxyOps Network Event Plugin (PowerShell 7)\nA collection of network diagnostic and analysis tools for xyOps including:\n- IP Address Tools (validate, convert, subnet calculator)\n- JWT Decoder\n- Ping Test\n- DNS Lookup\n- Traceroute\n- Port Scanner\n- HTTP Status Checker\n- SSL Certificate Checker\n- WHOIS Lookup\n\nI/O contract:\n- Read one JSON object from STDIN (job), write progress/messages as JSON lines of the\n  form: { \"xy\": 1, ... } to STDOUT.\n- On success, emit: { \"xy\": 1, \"code\": 0, \"data\": <result>, \"description\": \"...\" }\n- On error, emit:   { \"xy\": 1, \"code\": <nonzero>, \"description\": \"...\" } and exit 1.\n\nTest locally:\n  pwsh -NoProfile -ExecutionPolicy Bypass -File .\\network.ps1 < job.json\n#>\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = 'Stop'\n\nfunction Write-XY {\n  param([hashtable]$Object)\n  $payload = [ordered]@{ xy = 1 }\n  foreach ($k in $Object.Keys) { $payload[$k] = $Object[$k] }\n  [Console]::Out.WriteLine(($payload | ConvertTo-Json -Depth 20 -Compress))\n  [Console]::Out.Flush()\n}\n\nfunction Write-XYProgress {\n  param([double]$Value, [string]$Status)\n  $o = @{ progress = [math]::Round($Value, 4) }\n  if ($Status) { $o.status = $Status }\n  Write-XY $o\n}\n\nfunction Write-XYSuccess {\n  param($Data, [string]$Description)\n  $o = @{ code = 0; data = $Data }\n  if ($Description) { $o.description = $Description }\n  Write-XY $o\n}\n\nfunction Write-XYError {\n  param([int]$Code, [string]$Description)\n  Write-XY @{ code = $Code; description = $Description }\n}\n\nfunction Read-JobFromStdin {\n  $raw = [Console]::In.ReadToEnd()\n  if ([string]::IsNullOrWhiteSpace($raw)) { throw 'No job JSON received on STDIN' }\n  return $raw | ConvertFrom-Json -ErrorAction Stop\n}\n\nfunction Get-NestedValue {\n  param($Object, [string]$Path)\n  if (-not $Path -or ($Path.Trim() -eq '')) { return $Object }\n  $cur = $Object\n  foreach ($part in $Path.Split('.')) {\n    if ($null -eq $cur) { return $null }\n    if ($cur -is [System.Collections.IDictionary]) {\n      if (-not $cur.Contains($part)) { return $null }\n      $cur = $cur[$part]\n    }\n    else {\n      $cur = $cur.PSObject.Properties[$part].Value\n    }\n  }\n  return $cur\n}\n\n# Safe parameter getter - returns default if property doesn't exist\nfunction Get-Param {\n  param($Params, [string]$Name, $Default = $null)\n  if ($Params.PSObject.Properties.Name -contains $Name) { return $Params.$Name }\n  return $Default\n}\n\n# Parse multiple inputs from string (comma/newline separated) or array\nfunction Get-MultipleInputs {\n  param($Value, [int]$MaxItems = 20)\n  $items = @()\n  if ($null -eq $Value) { return $items }\n  # Check if it's a collection (Object[], ArrayList, etc.) but not a string\n  if ($Value -is [System.Collections.IEnumerable] -and $Value -isnot [string]) {\n    $items = @($Value | ForEach-Object { if ($_ -is [string]) { $_.Trim() } else { [string]$_ } } | Where-Object { $_ -ne '' })\n  } else {\n    # Input is a string - split by comma or newline\n    $items = @([string]$Value -split '[,\\n\\r]+' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' })\n  }\n  return @($items | Select-Object -First $MaxItems)\n}\n\n# ------------------------- IP Address Tools -------------------------\nfunction Invoke-IPAddressTools {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $mode = ($Params.ipMode ?? 'validate')\n  $source = ($Params.ipSource ?? 'field')\n  $ipInput = ''\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = ($Params.ipDataPath ?? '')\n    $val = Get-NestedValue $inputData $path\n    if ($null -eq $val) { throw \"Data path '$path' not found in input data\" }\n    $ipInput = [string]$val\n  } else { $ipInput = ($Params.ipInput ?? '') }\n  \n  if (-not $ipInput) { throw 'No IP address provided' }\n  \n  Write-XYProgress 0.5 'Processing IP address...'\n  \n  $ipInput = $ipInput.Trim()\n  $rows = @()\n  $result = @{ tool='IP Address Tools'; mode=$mode; input=$ipInput }\n  \n  switch ($mode) {\n    'validate' {\n      $ipv4Valid = $false; $ipv6Valid = $false; $type = 'Invalid'\n      try {\n        $ip = [System.Net.IPAddress]::Parse($ipInput)\n        if ($ip.AddressFamily -eq 'InterNetwork') { $ipv4Valid = $true; $type = 'IPv4' }\n        elseif ($ip.AddressFamily -eq 'InterNetworkV6') { $ipv6Valid = $true; $type = 'IPv6' }\n      } catch {}\n      $isPrivate = $false; $isLoopback = $false; $class = 'N/A'\n      if ($ipv4Valid) {\n        $octets = $ipInput -split '\\.' | ForEach-Object { [int]$_ }\n        if ($octets[0] -eq 10) { $isPrivate = $true }\n        elseif ($octets[0] -eq 172 -and $octets[1] -ge 16 -and $octets[1] -le 31) { $isPrivate = $true }\n        elseif ($octets[0] -eq 192 -and $octets[1] -eq 168) { $isPrivate = $true }\n        elseif ($octets[0] -eq 127) { $isLoopback = $true }\n        if ($octets[0] -le 127) { $class = 'A' }\n        elseif ($octets[0] -le 191) { $class = 'B' }\n        elseif ($octets[0] -le 223) { $class = 'C' }\n        elseif ($octets[0] -le 239) { $class = 'D (Multicast)' }\n        else { $class = 'E (Reserved)' }\n      }\n      $rows = @(@('IP Address', $ipInput), @('Valid', $(if ($ipv4Valid -or $ipv6Valid) { '✓ Yes' } else { '✗ No' })), @('Type', $type), @('Class', $class), @('Private', $(if ($isPrivate) { 'Yes' } else { 'No' })), @('Loopback', $(if ($isLoopback) { 'Yes' } else { 'No' })))\n      $result.valid = ($ipv4Valid -or $ipv6Valid); $result.type = $type; $result.class = $class; $result.isPrivate = $isPrivate; $result.isLoopback = $isLoopback\n    }\n    'toDecimal' {\n      $octets = $ipInput -split '\\.' | ForEach-Object { [int]$_ }\n      if ($octets.Count -ne 4) { throw 'Invalid IPv4 address' }\n      $decimal = ([long]$octets[0] * 16777216) + ([long]$octets[1] * 65536) + ([long]$octets[2] * 256) + [long]$octets[3]\n      $rows = @(@('IPv4 Address', $ipInput), @('Decimal', $decimal))\n      $result.decimal = $decimal\n    }\n    'fromDecimal' {\n      $dec = [long]$ipInput\n      $o1 = [Math]::Floor($dec / 16777216) % 256; $o2 = [Math]::Floor($dec / 65536) % 256\n      $o3 = [Math]::Floor($dec / 256) % 256; $o4 = $dec % 256\n      $ipv4 = \"$o1.$o2.$o3.$o4\"\n      $rows = @(@('Decimal', $dec), @('IPv4 Address', $ipv4))\n      $result.ipv4 = $ipv4\n    }\n    'toBinary' {\n      $octets = $ipInput -split '\\.' | ForEach-Object { [int]$_ }\n      if ($octets.Count -ne 4) { throw 'Invalid IPv4 address' }\n      $binary = ($octets | ForEach-Object { [Convert]::ToString($_, 2).PadLeft(8, '0') }) -join '.'\n      $rows = @(@('IPv4 Address', $ipInput), @('Binary', $binary))\n      $result.binary = $binary\n    }\n    'subnet' {\n      if ($ipInput -notmatch '/') { throw 'Please provide IP in CIDR notation (e.g., 192.168.1.0/24)' }\n      $parts = $ipInput -split '/'; $ip = $parts[0]; $cidr = [int]$parts[1]\n      $octets = $ip -split '\\.' | ForEach-Object { [int]$_ }\n      $mask = ([Math]::Pow(2, 32) - [Math]::Pow(2, 32 - $cidr))\n      $m1 = [Math]::Floor($mask / 16777216) % 256; $m2 = [Math]::Floor($mask / 65536) % 256\n      $m3 = [Math]::Floor($mask / 256) % 256; $m4 = $mask % 256\n      $subnetMask = \"$m1.$m2.$m3.$m4\"\n      $networkAddr = \"$($octets[0] -band $m1).$($octets[1] -band $m2).$($octets[2] -band $m3).$($octets[3] -band $m4)\"\n      $hostCount = [Math]::Pow(2, 32 - $cidr) - 2\n      $rows = @(@('CIDR', $ipInput), @('Subnet Mask', $subnetMask), @('Network Address', $networkAddr), @('Usable Hosts', $(if ($hostCount -gt 0) { $hostCount } else { 0 })))\n      $result.subnetMask = $subnetMask; $result.networkAddress = $networkAddr; $result.usableHosts = $hostCount\n    }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  $modeNames = @{ validate='Validate'; toDecimal='IP to Decimal'; fromDecimal='Decimal to IP'; toBinary='IP to Binary'; subnet='Subnet Calculator' }\n  Write-XY @{ table = @{ title=\"IP Address - $($modeNames[$mode])\"; header=@('Property','Value'); rows=$rows; caption='IP address processed' } }\n  [pscustomobject]$result\n}\n\n# ------------------------- JWT Decoder -------------------------\nfunction Invoke-JWTDecoder {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $source = ($Params.jwtSource ?? 'field')\n  $token = ''\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = ($Params.jwtDataPath ?? '')\n    $val = Get-NestedValue $inputData $path\n    if ($null -eq $val) { throw \"Data path '$path' not found in input data\" }\n    $token = [string]$val\n  } else { $token = ($Params.jwtInput ?? '') }\n  \n  if (-not $token) { throw 'No JWT token provided' }\n  \n  Write-XYProgress 0.5 'Decoding JWT...'\n  \n  $token = $token.Trim()\n  $parts = $token -split '\\.'\n  if ($parts.Count -ne 3) { throw 'Invalid JWT format (expected 3 parts separated by dots)' }\n  \n  # Base64URL decode helper\n  $decodeBase64Url = {\n    param($s)\n    $s = $s.Replace('-', '+').Replace('_', '/')\n    switch ($s.Length % 4) { 2 { $s += '==' } 3 { $s += '=' } }\n    [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($s))\n  }\n  \n  $headerJson = & $decodeBase64Url $parts[0]\n  $payloadJson = & $decodeBase64Url $parts[1]\n  $header = $headerJson | ConvertFrom-Json\n  $payload = $payloadJson | ConvertFrom-Json\n  \n  # Helper to safely get property from PSCustomObject\n  $getProp = { param($obj, $name, $default)\n    if ($null -ne $obj.PSObject -and $obj.PSObject.Properties.Name -contains $name) {\n      $val = $obj.$name\n      if ($null -ne $val) { return $val }\n    }\n    return $default\n  }\n  \n  # Extract common claims\n  $alg = & $getProp $header 'alg' 'N/A'\n  $typ = & $getProp $header 'typ' 'N/A'\n  $iss = & $getProp $payload 'iss' 'N/A'\n  $sub = & $getProp $payload 'sub' 'N/A'\n  $audVal = & $getProp $payload 'aud' $null\n  $aud = if ($null -ne $audVal) { if ($audVal -is [array]) { $audVal -join ', ' } else { $audVal } } else { 'N/A' }\n  $exp = 'N/A'; $expDate = 'N/A'\n  $expVal = & $getProp $payload 'exp' $null\n  if ($null -ne $expVal) {\n    $exp = $expVal\n    $expDate = [DateTimeOffset]::FromUnixTimeSeconds($expVal).DateTime.ToString('yyyy-MM-dd HH:mm:ss UTC')\n  }\n  $iat = 'N/A'; $iatDate = 'N/A'\n  $iatVal = & $getProp $payload 'iat' $null\n  if ($null -ne $iatVal) {\n    $iat = $iatVal\n    $iatDate = [DateTimeOffset]::FromUnixTimeSeconds($iatVal).DateTime.ToString('yyyy-MM-dd HH:mm:ss UTC')\n  }\n  \n  $isExpired = $false\n  if ($null -ne $expVal) { $isExpired = [DateTimeOffset]::UtcNow.ToUnixTimeSeconds() -gt $expVal }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  Write-XY @{ table = @{ title='JWT Header'; header=@('Property','Value'); rows=@(@('Algorithm', $alg), @('Type', $typ)); caption='' } }\n  Write-XY @{ table = @{ title='JWT Payload'; header=@('Property','Value'); rows=@(@('Issuer (iss)', $iss), @('Subject (sub)', $sub), @('Audience (aud)', $aud), @('Issued At (iat)', \"$iat ($iatDate)\"), @('Expires (exp)', \"$exp ($expDate)\"), @('Expired?', $(if ($isExpired) { '✗ Yes' } else { '✓ No' }))); caption=$(if ($isExpired) { 'Token has expired' } else { 'Token is still valid' }) } }\n  Write-XY @{ text = @{ title='Full Payload'; content=$payloadJson; caption='' } }\n  [pscustomobject]@{ tool='JWT Decoder'; algorithm=$alg; type=$typ; issuer=$iss; subject=$sub; audience=$aud; issuedAt=$iat; expiresAt=$exp; isExpired=$isExpired; header=$header; payload=$payload }\n}\n\n# ------------------------- Ping Test -------------------------\nfunction Invoke-PingTest {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = Get-Param $Params 'pingSource' 'field'\n  $hostsInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'pingDataPath' ''\n    $hostsInput = Get-NestedValue $inputData $path\n    if ($null -eq $hostsInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $hostsInput = Get-Param $Params 'pingHosts' '' }\n  \n  $hosts = @(Get-MultipleInputs $hostsInput 20)\n  if ($hosts.Count -eq 0) { throw 'No host(s) specified' }\n  \n  $count = [Math]::Min(10, [Math]::Max(1, [int](Get-Param $Params 'pingCount' 4)))\n  $timeout = [Math]::Min(30000, [Math]::Max(100, [int](Get-Param $Params 'pingTimeout' 1000)))\n  \n  Write-XYProgress 0.2 \"Pinging $($hosts.Count) host(s)...\"\n  \n  $pinger = [System.Net.NetworkInformation.Ping]::new()\n  $allResults = [System.Collections.Generic.List[object]]::new()\n  $totalSuccess = 0\n  $totalFail = 0\n  \n  $hostIndex = 0\n  foreach ($host_ in $hosts) {\n    $hostIndex++\n    Write-XYProgress (0.2 + (0.7 * $hostIndex / $hosts.Count)) \"Pinging $host_...\"\n    \n    $results = [System.Collections.Generic.List[object]]::new()\n    $successful = 0\n    $failed = 0\n    $latencies = [System.Collections.Generic.List[long]]::new()\n    $resolvedIP = ''\n    $hostError = $null\n    \n    try {\n      try { $resolvedIP = ([System.Net.Dns]::GetHostAddresses($host_) | Select-Object -First 1).ToString() } catch { }\n      \n      for ($i = 1; $i -le $count; $i++) {\n        try {\n          $reply = $pinger.Send($host_, $timeout)\n          if ($reply.Status -eq [System.Net.NetworkInformation.IPStatus]::Success) {\n            $successful++\n            $latencies.Add($reply.RoundtripTime)\n            $ttlVal = if ($null -ne $reply.Options) { $reply.Options.Ttl } else { '-' }\n            $addrVal = if ($null -ne $reply.Address) { $reply.Address.ToString() } else { '-' }\n            $results.Add([pscustomobject]@{ seq=$i; status='Success'; time=\"$($reply.RoundtripTime)ms\"; ttl=$ttlVal; address=$addrVal })\n          } else {\n            $failed++\n            $results.Add([pscustomobject]@{ seq=$i; status=$reply.Status.ToString(); time='-'; ttl='-'; address='-' })\n          }\n        } catch {\n          $failed++\n          $errMsg = $_.Exception.Message\n          if ($errMsg.Length -gt 50) { $errMsg = $errMsg.Substring(0, 47) + '...' }\n          $results.Add([pscustomobject]@{ seq=$i; status=\"Error: $errMsg\"; time='-'; ttl='-'; address='-' })\n        }\n        if ($i -lt $count) { Start-Sleep -Milliseconds 100 }\n      }\n    } catch {\n      $hostError = $_.Exception.Message\n    }\n    \n    $minLatency = if ($latencies.Count -gt 0) { ($latencies | Measure-Object -Minimum).Minimum } else { $null }\n    $maxLatency = if ($latencies.Count -gt 0) { ($latencies | Measure-Object -Maximum).Maximum } else { $null }\n    $avgLatency = if ($latencies.Count -gt 0) { [Math]::Round(($latencies | Measure-Object -Average).Average, 2) } else { $null }\n    $lossPercent = if ($count -gt 0) { [Math]::Round(($failed / $count) * 100, 1) } else { 100 }\n    \n    if ($successful -gt 0) { $totalSuccess++ } else { $totalFail++ }\n    \n    # Build output table for this host\n    $rows = @()\n    foreach ($r in $results) {\n      $rows += ,@($r.seq, $r.status, $r.time, $r.ttl, $r.address)\n    }\n    $resultCaption = if ($hostError) { \"Error: $hostError\" } elseif ($successful -eq $count) { \"All $count pings successful\" } elseif ($successful -eq 0) { \"All $count pings failed\" } else { \"$successful/$count successful, $lossPercent% loss\" }\n    Write-XY @{ table = @{ title=\"Ping Results - $host_\"; header=@('Seq','Status','Time','TTL','Address'); rows=$rows; caption=$resultCaption } }\n    \n    $statsRows = @(\n      @('Host', $host_),\n      @('Resolved IP', $(if ($resolvedIP) { $resolvedIP } else { 'N/A' })),\n      @('Packets Sent', $count),\n      @('Packets Received', $successful),\n      @('Loss Percentage', \"$lossPercent%\")\n    )\n    if ($latencies.Count -gt 0) {\n      $statsRows += @(@('Min Latency', \"${minLatency}ms\"), @('Max Latency', \"${maxLatency}ms\"), @('Avg Latency', \"${avgLatency}ms\"))\n    }\n    Write-XY @{ table = @{ title=\"Statistics - $host_\"; header=@('Metric','Value'); rows=$statsRows; caption='' } }\n    \n    $allResults.Add([pscustomobject]@{\n      host=$host_; resolvedIP=$resolvedIP; count=$count; successful=$successful; failed=$failed\n      lossPercent=$lossPercent; minLatency=$minLatency; maxLatency=$maxLatency; avgLatency=$avgLatency\n      error=$hostError; results=$results.ToArray()\n    })\n  }\n  $pinger.Dispose()\n  \n  # Summary table if multiple hosts\n  if ($hosts.Count -gt 1) {\n    $summaryRows = @()\n    foreach ($r in $allResults) {\n      $status = if ($r.successful -gt 0) { 'OK' } else { 'FAIL' }\n      $avg = if ($null -ne $r.avgLatency) { \"$($r.avgLatency)ms\" } else { '-' }\n      $summaryRows += ,@($r.host, $status, \"$($r.lossPercent)%\", $avg)\n    }\n    Write-XY @{ table = @{ title='Ping Summary'; header=@('Host','Status','Loss','Avg Latency'); rows=$summaryRows; caption=\"$totalSuccess/$($hosts.Count) hosts reachable\" } }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  if ($totalSuccess -eq 0) {\n    throw \"Ping failed: All $($hosts.Count) host(s) unreachable\"\n  }\n  \n  [pscustomobject]@{ tool='Ping Test'; hostsChecked=$hosts.Count; successful=$totalSuccess; failed=$totalFail; results=$allResults.ToArray() }\n}\n\n# ------------------------- DNS Lookup -------------------------\nfunction Invoke-DnsLookup {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = Get-Param $Params 'dnsSource' 'field'\n  $queriesInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'dnsDataPath' ''\n    $queriesInput = Get-NestedValue $inputData $path\n    if ($null -eq $queriesInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $queriesInput = Get-Param $Params 'dnsQueries' '' }\n  \n  $queries = @(Get-MultipleInputs $queriesInput 20)\n  if ($queries.Count -eq 0) { throw 'No query specified' }\n  \n  $recordType = Get-Param $Params 'dnsRecordType' 'A'\n  $dnsServer = Get-Param $Params 'dnsServer' ''\n  \n  Write-XYProgress 0.2 \"Resolving $recordType records for $($queries.Count) domain(s)...\"\n  \n  $allResults = [System.Collections.Generic.List[object]]::new()\n  $totalSuccess = 0\n  $totalFail = 0\n  \n  $queryIndex = 0\n  foreach ($query in $queries) {\n    $queryIndex++\n    Write-XYProgress (0.2 + (0.7 * $queryIndex / $queries.Count)) \"Resolving $query...\"\n    \n    $results = [System.Collections.Generic.List[object]]::new()\n    $success = $true\n    $errorMsg = ''\n    \n    try {\n      if ($recordType -eq 'PTR') {\n        $ip = [System.Net.IPAddress]::Parse($query)\n        $hostEntry = [System.Net.Dns]::GetHostEntry($ip)\n        $results.Add([pscustomobject]@{ type='PTR'; name=$query; value=$hostEntry.HostName; ttl='-' })\n      }\n      elseif ($recordType -eq 'A' -or $recordType -eq 'AAAA') {\n        $addresses = [System.Net.Dns]::GetHostAddresses($query)\n        foreach ($addr in $addresses) {\n          if ($recordType -eq 'A' -and $addr.AddressFamily -eq 'InterNetwork') {\n            $results.Add([pscustomobject]@{ type='A'; name=$query; value=$addr.ToString(); ttl='-' })\n          }\n          elseif ($recordType -eq 'AAAA' -and $addr.AddressFamily -eq 'InterNetworkV6') {\n            $results.Add([pscustomobject]@{ type='AAAA'; name=$query; value=$addr.ToString(); ttl='-' })\n          }\n        }\n        if ($results.Count -eq 0) { $results.Add([pscustomobject]@{ type=$recordType; name=$query; value='No records found'; ttl='-' }) }\n      }\n      else {\n        $nslookupArgs = if ($dnsServer) { \"-type=$recordType $query $dnsServer\" } else { \"-type=$recordType $query\" }\n        $output = & nslookup $nslookupArgs.Split(' ') 2>&1\n        $outputText = $output -join \"`n\"\n        \n        switch ($recordType) {\n          'MX' {\n            $regMatches = [regex]::Matches($outputText, 'mail exchanger = (.+)')\n            foreach ($m in $regMatches) {\n              $parts = $m.Groups[1].Value.Trim() -split '\\s+'\n              $priority = if ($parts.Count -gt 1) { $parts[0] } else { '-' }\n              $srv = if ($parts.Count -gt 1) { $parts[-1] } else { $parts[0] }\n              $results.Add([pscustomobject]@{ type='MX'; name=$query; value=\"$priority $srv\"; ttl='-' })\n            }\n          }\n          'TXT' {\n            $regMatches = [regex]::Matches($outputText, 'text\\s*=\\s*\"([^\"]+)\"')\n            foreach ($m in $regMatches) {\n              $results.Add([pscustomobject]@{ type='TXT'; name=$query; value=$m.Groups[1].Value; ttl='-' })\n            }\n          }\n          'NS' {\n            $regMatches = [regex]::Matches($outputText, 'nameserver = (.+)')\n            foreach ($m in $regMatches) {\n              $results.Add([pscustomobject]@{ type='NS'; name=$query; value=$m.Groups[1].Value.Trim(); ttl='-' })\n            }\n          }\n          'CNAME' {\n            $regMatches = [regex]::Matches($outputText, 'canonical name = (.+)')\n            foreach ($m in $regMatches) {\n              $results.Add([pscustomobject]@{ type='CNAME'; name=$query; value=$m.Groups[1].Value.Trim(); ttl='-' })\n            }\n          }\n          'SOA' {\n            if ($outputText -match 'primary name server = ([^\\s]+)') {\n              $soa = $Matches[1]\n              $results.Add([pscustomobject]@{ type='SOA'; name=$query; value=\"Primary: $soa\"; ttl='-' })\n            }\n          }\n        }\n        if ($results.Count -eq 0) { $results.Add([pscustomobject]@{ type=$recordType; name=$query; value='No records found'; ttl='-' }) }\n      }\n      $totalSuccess++\n    } catch {\n      $success = $false\n      $errorMsg = $_.Exception.Message\n      $results.Add([pscustomobject]@{ type=$recordType; name=$query; value=\"Error: $errorMsg\"; ttl='-' })\n      $totalFail++\n    }\n    \n    # Output table for this query\n    $rows = @()\n    foreach ($r in $results) {\n      $rows += ,@($r.type, $r.name, $r.value, $r.ttl)\n    }\n    Write-XY @{ table = @{ title=\"DNS Lookup - $query ($recordType)\"; header=@('Type','Name','Value','TTL'); rows=$rows; caption=$(if ($dnsServer) { \"Using DNS server: $dnsServer\" } else { 'Using system DNS' }) } }\n    \n    $allResults.Add([pscustomobject]@{ query=$query; recordType=$recordType; success=$success; results=$results.ToArray(); error=$errorMsg })\n  }\n  \n  # Summary table if multiple queries\n  if ($queries.Count -gt 1) {\n    $summaryRows = @()\n    foreach ($r in $allResults) {\n      $status = if ($r.success) { 'OK' } else { 'FAIL' }\n      $recordCount = ($r.results | Where-Object { $_.value -notmatch '^(Error|No records)' }).Count\n      $summaryRows += ,@($r.query, $status, $recordCount)\n    }\n    Write-XY @{ table = @{ title='DNS Summary'; header=@('Query','Status','Records'); rows=$summaryRows; caption=\"$totalSuccess/$($queries.Count) queries successful\" } }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  [pscustomobject]@{ tool='DNS Lookup'; queriesChecked=$queries.Count; successful=$totalSuccess; failed=$totalFail; recordType=$recordType; dnsServer=$(if ($dnsServer) { $dnsServer } else { 'system' }); results=$allResults.ToArray() }\n}\n\n# ------------------------- Traceroute -------------------------\nfunction Invoke-Traceroute {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = Get-Param $Params 'traceSource' 'field'\n  $hostsInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'traceDataPath' ''\n    $hostsInput = Get-NestedValue $inputData $path\n    if ($null -eq $hostsInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $hostsInput = Get-Param $Params 'traceHosts' '' }\n  \n  $hosts = @(Get-MultipleInputs $hostsInput 10)\n  if ($hosts.Count -eq 0) { throw 'No host(s) specified' }\n  \n  $maxHops = [Math]::Min(64, [Math]::Max(1, [int](Get-Param $Params 'traceMaxHops' 30)))\n  $timeout = [Math]::Min(10000, [Math]::Max(100, [int](Get-Param $Params 'traceTimeout' 3000)))\n  $resolveNames = if ($Params.PSObject.Properties.Name -contains 'traceResolveNames') { [bool]$Params.traceResolveNames } else { $true }\n  \n  Write-XYProgress 0.2 \"Tracing route to $($hosts.Count) host(s)...\"\n  \n  $pinger = [System.Net.NetworkInformation.Ping]::new()\n  $allResults = [System.Collections.Generic.List[object]]::new()\n  $totalReached = 0\n  \n  $hostIndex = 0\n  foreach ($host_ in $hosts) {\n    $hostIndex++\n    Write-XYProgress (0.2 + (0.7 * $hostIndex / $hosts.Count)) \"Tracing $host_...\"\n    \n    $options = [System.Net.NetworkInformation.PingOptions]::new()\n    $buffer = [byte[]]::new(32)\n    $results = [System.Collections.Generic.List[object]]::new()\n    $reached = $false\n    $destIP = ''\n    \n    try { $destIP = ([System.Net.Dns]::GetHostAddresses($host_) | Where-Object { $_.AddressFamily -eq 'InterNetwork' } | Select-Object -First 1).ToString() } catch { $destIP = $host_ }\n    \n    for ($ttl = 1; $ttl -le $maxHops; $ttl++) {\n      $options.Ttl = $ttl\n      $hopIP = '*'; $hopName = '*'; $hopTime = '*'\n      \n      try {\n        $reply = $pinger.Send($host_, $timeout, $buffer, $options)\n        if ($reply.Status -eq 'TtlExpired' -or $reply.Status -eq 'Success') {\n          $hopIP = $reply.Address.ToString()\n          $hopTime = \"$($reply.RoundtripTime)ms\"\n          if ($resolveNames) {\n            try { $hopName = ([System.Net.Dns]::GetHostEntry($reply.Address)).HostName } catch { $hopName = $hopIP }\n          } else { $hopName = $hopIP }\n          if ($reply.Status -eq 'Success') { $reached = $true }\n        } elseif ($reply.Status -eq 'TimedOut') {\n          $hopName = 'Request timed out'\n        }\n      } catch { $hopName = 'Error' }\n      \n      $results.Add([pscustomobject]@{ hop=$ttl; ip=$hopIP; hostname=$hopName; time=$hopTime })\n      if ($reached) { break }\n    }\n    \n    if ($reached) { $totalReached++ }\n    \n    $rows = @()\n    foreach ($r in $results) { $rows += ,@($r.hop, $r.ip, $r.hostname, $r.time) }\n    Write-XY @{ table = @{ title=\"Traceroute - $host_\"; header=@('Hop','IP Address','Hostname','Time'); rows=$rows; caption=$(if ($reached) { \"Destination reached in $($results.Count) hops\" } else { \"Destination not reached within $maxHops hops\" }) } }\n    \n    $allResults.Add([pscustomobject]@{ host=$host_; destinationIP=$destIP; hopsUsed=$results.Count; reached=$reached; results=$results.ToArray() })\n  }\n  $pinger.Dispose()\n  \n  if ($hosts.Count -gt 1) {\n    $summaryRows = @()\n    foreach ($r in $allResults) {\n      $status = if ($r.reached) { 'OK' } else { 'FAIL' }\n      $summaryRows += ,@($r.host, $status, $r.hopsUsed)\n    }\n    Write-XY @{ table = @{ title='Traceroute Summary'; header=@('Host','Status','Hops'); rows=$summaryRows; caption=\"$totalReached/$($hosts.Count) hosts reached\" } }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  [pscustomobject]@{ tool='Traceroute'; hostsChecked=$hosts.Count; reached=$totalReached; maxHops=$maxHops; results=$allResults.ToArray() }\n}\n\n# ------------------------- Port Scanner -------------------------\nfunction Invoke-PortScanner {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = Get-Param $Params 'portSource' 'field'\n  $hostsInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'portDataPath' ''\n    $hostsInput = Get-NestedValue $inputData $path\n    if ($null -eq $hostsInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $hostsInput = Get-Param $Params 'portHosts' '' }\n  \n  $hosts = @(Get-MultipleInputs $hostsInput 20)\n  if ($hosts.Count -eq 0) { throw 'No host(s) specified' }\n  \n  $portsInput = Get-Param $Params 'portPorts' '80,443'\n  $timeout = [Math]::Min(30000, [Math]::Max(100, [int](Get-Param $Params 'portTimeout' 1000)))\n  \n  $ports = [System.Collections.Generic.List[int]]::new()\n  foreach ($part in ($portsInput -split ',')) {\n    $part = $part.Trim()\n    if ($part -match '^(\\d+)-(\\d+)$') {\n      $start = [int]$Matches[1]; $end = [int]$Matches[2]\n      for ($p = $start; $p -le $end -and $ports.Count -lt 100; $p++) { $ports.Add($p) }\n    } elseif ($part -match '^\\d+$') {\n      if ($ports.Count -lt 100) { $ports.Add([int]$part) }\n    }\n  }\n  if ($ports.Count -eq 0) { throw 'No valid ports specified' }\n  \n  Write-XYProgress 0.2 \"Scanning $($ports.Count) port(s) on $($hosts.Count) host(s)...\"\n  \n  $commonPorts = @{\n    20='FTP Data'; 21='FTP'; 22='SSH'; 23='Telnet'; 25='SMTP'; 53='DNS'; 80='HTTP'; 110='POP3'\n    143='IMAP'; 443='HTTPS'; 465='SMTPS'; 587='SMTP Submission'; 993='IMAPS'; 995='POP3S'\n    3306='MySQL'; 3389='RDP'; 5432='PostgreSQL'; 6379='Redis'; 8080='HTTP Proxy'; 8443='HTTPS Alt'\n  }\n  \n  $allResults = [System.Collections.Generic.List[object]]::new()\n  $totalWithOpen = 0\n  \n  $hostIndex = 0\n  foreach ($host_ in $hosts) {\n    $hostIndex++\n    Write-XYProgress (0.2 + (0.7 * $hostIndex / $hosts.Count)) \"Scanning $host_...\"\n    \n    $results = [System.Collections.Generic.List[object]]::new()\n    $openPorts = 0\n    $closedPorts = 0\n    \n    foreach ($port in $ports) {\n      $status = 'Closed'\n      $service = if ($commonPorts.ContainsKey($port)) { $commonPorts[$port] } else { '-' }\n      \n      try {\n        $client = [System.Net.Sockets.TcpClient]::new()\n        $result = $client.BeginConnect($host_, $port, $null, $null)\n        $success = $result.AsyncWaitHandle.WaitOne($timeout, $false)\n        if ($success -and $client.Connected) {\n          $status = 'Open'\n          $openPorts++\n        } else { $closedPorts++ }\n        $client.Close()\n      } catch { $closedPorts++ }\n      \n      $results.Add([pscustomobject]@{ port=$port; status=$status; service=$service })\n    }\n    \n    if ($openPorts -gt 0) { $totalWithOpen++ }\n    \n    $rows = @()\n    foreach ($r in $results) { $rows += ,@($r.port, $r.status, $r.service) }\n    Write-XY @{ table = @{ title=\"Port Scan - $host_\"; header=@('Port','Status','Service'); rows=$rows; caption=\"$openPorts open, $closedPorts closed\" } }\n    \n    $allResults.Add([pscustomobject]@{ host=$host_; portsScanned=$ports.Count; openPorts=$openPorts; closedPorts=$closedPorts; results=$results.ToArray() })\n  }\n  \n  if ($hosts.Count -gt 1) {\n    $summaryRows = @()\n    foreach ($r in $allResults) {\n      $status = if ($r.openPorts -gt 0) { 'OK' } else { 'CLOSED' }\n      $summaryRows += ,@($r.host, $status, $r.openPorts, $r.closedPorts)\n    }\n    Write-XY @{ table = @{ title='Port Scan Summary'; header=@('Host','Status','Open','Closed'); rows=$summaryRows; caption=\"$totalWithOpen/$($hosts.Count) hosts with open ports\" } }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  [pscustomobject]@{ tool='Port Scanner'; hostsChecked=$hosts.Count; hostsWithOpenPorts=$totalWithOpen; timeout=$timeout; results=$allResults.ToArray() }\n}\n\n# ------------------------- HTTP Status Checker -------------------------\nfunction Invoke-HttpChecker {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = Get-Param $Params 'httpSource' 'field'\n  $urlsInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'httpDataPath' ''\n    $urlsInput = Get-NestedValue $inputData $path\n    if ($null -eq $urlsInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $urlsInput = Get-Param $Params 'httpUrls' '' }\n  \n  $urls = @(Get-MultipleInputs $urlsInput 20)\n  if ($urls.Count -eq 0) { throw 'No URL(s) specified' }\n  \n  $method = Get-Param $Params 'httpMethod' 'GET'\n  $timeout = [Math]::Min(60, [Math]::Max(1, [int](Get-Param $Params 'httpTimeout' 10)))\n  $followRedirects = if ($Params.PSObject.Properties.Name -contains 'httpFollowRedirects') { [bool]$Params.httpFollowRedirects } else { $true }\n  \n  Write-XYProgress 0.2 \"Checking $($urls.Count) URL(s)...\"\n  \n  $allResults = [System.Collections.Generic.List[object]]::new()\n  $totalSuccess = 0\n  $totalFail = 0\n  \n  $urlIndex = 0\n  foreach ($url in $urls) {\n    $urlIndex++\n    if ($url -notmatch '^https?://') { $url = \"https://$url\" }\n    Write-XYProgress (0.2 + (0.7 * $urlIndex / $urls.Count)) \"Checking $url...\"\n    \n    $statusCode = 0; $statusDesc = ''; $responseTime = 0; $headers = @{}\n    $contentType = ''; $contentLength = 0; $server = ''; $redirectUrl = ''; $errorMsg = ''; $success = $true\n    \n    try {\n      $handler = [System.Net.Http.HttpClientHandler]::new()\n      $handler.AllowAutoRedirect = $followRedirects\n      $client = [System.Net.Http.HttpClient]::new($handler)\n      $client.Timeout = [TimeSpan]::FromSeconds($timeout)\n      \n      $sw = [System.Diagnostics.Stopwatch]::StartNew()\n      $response = switch ($method) {\n        'GET' { $client.GetAsync($url).Result }\n        'HEAD' { $client.SendAsync([System.Net.Http.HttpRequestMessage]::new([System.Net.Http.HttpMethod]::Head, $url)).Result }\n        'POST' { $client.PostAsync($url, [System.Net.Http.StringContent]::new('')).Result }\n        default { $client.GetAsync($url).Result }\n      }\n      $sw.Stop()\n      $responseTime = $sw.ElapsedMilliseconds\n      \n      $statusCode = [int]$response.StatusCode\n      $statusDesc = $response.ReasonPhrase\n      \n      foreach ($h in $response.Headers) { $headers[$h.Key] = ($h.Value -join ', ') }\n      foreach ($h in $response.Content.Headers) { $headers[$h.Key] = ($h.Value -join ', ') }\n      \n      $contentType = if ($headers.ContainsKey('Content-Type')) { $headers['Content-Type'] } else { '-' }\n      $contentLength = if ($headers.ContainsKey('Content-Length')) { [long]$headers['Content-Length'] } else { 0 }\n      $server = if ($headers.ContainsKey('Server')) { $headers['Server'] } else { '-' }\n      \n      if (-not $followRedirects -and $statusCode -ge 300 -and $statusCode -lt 400) {\n        $redirectUrl = if ($headers.ContainsKey('Location')) { $headers['Location'] } else { '-' }\n      }\n      \n      $client.Dispose()\n      $totalSuccess++\n    } catch {\n      $success = $false\n      $errorMsg = $_.Exception.InnerException?.Message ?? $_.Exception.Message\n      $totalFail++\n    }\n    \n    $summaryRows = @(\n      @('URL', $url), @('Method', $method),\n      @('Status Code', $(if ($success) { \"$statusCode $statusDesc\" } else { 'Error' })),\n      @('Response Time', \"${responseTime}ms\"), @('Server', $server)\n    )\n    if ($errorMsg) { $summaryRows += ,@('Error', $errorMsg) }\n    \n    Write-XY @{ table = @{ title=\"HTTP - $url\"; header=@('Property','Value'); rows=$summaryRows; caption=$(if ($success) { 'Request completed' } else { 'Request failed' }) } }\n    \n    $allResults.Add([pscustomobject]@{ url=$url; method=$method; success=$success; statusCode=$statusCode; statusDescription=$statusDesc; responseTime=$responseTime; contentType=$contentType; server=$server; error=$errorMsg })\n  }\n  \n  if ($urls.Count -gt 1) {\n    $summaryRows = @()\n    foreach ($r in $allResults) {\n      $status = if ($r.success) { \"$($r.statusCode)\" } else { 'FAIL' }\n      $summaryRows += ,@($r.url, $status, \"$($r.responseTime)ms\")\n    }\n    Write-XY @{ table = @{ title='HTTP Summary'; header=@('URL','Status','Response'); rows=$summaryRows; caption=\"$totalSuccess/$($urls.Count) requests successful\" } }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  [pscustomobject]@{ tool='HTTP Status Checker'; urlsChecked=$urls.Count; successful=$totalSuccess; failed=$totalFail; results=$allResults.ToArray() }\n}\n\n# ------------------------- SSL Certificate Checker -------------------------\nfunction Invoke-SslChecker {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = Get-Param $Params 'sslSource' 'field'\n  $hostsInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'sslDataPath' ''\n    $hostsInput = Get-NestedValue $inputData $path\n    if ($null -eq $hostsInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $hostsInput = Get-Param $Params 'sslHosts' '' }\n  \n  $hosts = @(Get-MultipleInputs $hostsInput 20)\n  if ($hosts.Count -eq 0) { throw 'No host(s) specified' }\n  \n  Write-XYProgress 0.2 \"Checking SSL certificates for $($hosts.Count) host(s)...\"\n  \n  $allResults = [System.Collections.Generic.List[object]]::new()\n  $totalSuccess = 0\n  $totalFail = 0\n  \n  $hostIndex = 0\n  foreach ($hostEntry in $hosts) {\n    $hostIndex++\n    $host_ = $hostEntry -replace '^https?://', '' -replace '/.*$', ''\n    $port = 443\n    if ($host_ -match '^(.+):(\\d+)$') { $host_ = $Matches[1]; $port = [int]$Matches[2] }\n    \n    Write-XYProgress (0.2 + (0.7 * $hostIndex / $hosts.Count)) \"Checking $host_`:$port...\"\n    \n    $cert = $null; $chain = $null; $success = $true; $errorMsg = ''\n    \n    try {\n      $client = [System.Net.Sockets.TcpClient]::new($host_, $port)\n      $sslStream = [System.Net.Security.SslStream]::new($client.GetStream(), $false, { $true })\n      $sslStream.AuthenticateAsClient($host_)\n      $cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new($sslStream.RemoteCertificate)\n      $chain = [System.Security.Cryptography.X509Certificates.X509Chain]::new()\n      $chain.Build($cert) | Out-Null\n      $sslStream.Close(); $client.Close()\n      $totalSuccess++\n    } catch {\n      $success = $false\n      $errorMsg = $_.Exception.InnerException?.Message ?? $_.Exception.Message\n      $totalFail++\n    }\n    \n    if ($success -and $cert) {\n      $now = [DateTime]::UtcNow\n      $notAfter = $cert.NotAfter.ToUniversalTime()\n      $daysUntilExpiry = [Math]::Floor(($notAfter - $now).TotalDays)\n      $isExpired = $now -gt $notAfter\n      $cn = ''; if ($cert.Subject -match 'CN=([^,]+)') { $cn = $Matches[1] }\n      $validity = if ($isExpired) { 'EXPIRED' } elseif ($daysUntilExpiry -le 30) { 'EXPIRING SOON' } else { 'Valid' }\n      \n      $summaryRows = @(\n        @('Host', \"$host_`:$port\"), @('Common Name', $cn),\n        @('Valid Until', $notAfter.ToString('yyyy-MM-dd')), @('Days Until Expiry', $daysUntilExpiry), @('Status', $validity)\n      )\n      Write-XY @{ table = @{ title=\"SSL - $host_\"; header=@('Property','Value'); rows=$summaryRows; caption=$validity } }\n      \n      $allResults.Add([pscustomobject]@{ host=\"$host_`:$port\"; success=$true; commonName=$cn; validUntil=$notAfter; daysUntilExpiry=$daysUntilExpiry; isExpired=$isExpired; validity=$validity })\n    } else {\n      Write-XY @{ table = @{ title=\"SSL - $host_\"; header=@('Property','Value'); rows=@(@('Host', \"$host_`:$port\"), @('Error', $errorMsg)); caption='Failed' } }\n      $allResults.Add([pscustomobject]@{ host=\"$host_`:$port\"; success=$false; error=$errorMsg })\n    }\n  }\n  \n  if ($hosts.Count -gt 1) {\n    $summaryRows = @()\n    foreach ($r in $allResults) {\n      $status = if ($r.success) { $r.validity } else { 'FAIL' }\n      $days = if ($r.success) { $r.daysUntilExpiry } else { '-' }\n      $summaryRows += ,@($r.host, $status, $days)\n    }\n    Write-XY @{ table = @{ title='SSL Summary'; header=@('Host','Status','Days Left'); rows=$summaryRows; caption=\"$totalSuccess/$($hosts.Count) certificates retrieved\" } }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  [pscustomobject]@{ tool='SSL Certificate Checker'; hostsChecked=$hosts.Count; successful=$totalSuccess; failed=$totalFail; results=$allResults.ToArray() }\n}\n\n# ------------------------- NTP Check -------------------------\nfunction Invoke-NtpCheck {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = Get-Param $Params 'ntpSource' 'field'\n  $serversInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'ntpDataPath' ''\n    $serversInput = Get-NestedValue $inputData $path\n    if ($null -eq $serversInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $serversInput = Get-Param $Params 'ntpServers' '' }\n  \n  $timeout = [Math]::Min(10000, [Math]::Max(500, [int](Get-Param $Params 'ntpTimeout' 3000)))\n  \n  # Parse servers using common function\n  $servers = @(Get-MultipleInputs $serversInput 10)\n  if ($servers.Count -eq 0) { throw 'No valid NTP servers specified' }\n  \n  Write-XYProgress 0.2 \"Checking $($servers.Count) NTP server(s)...\"\n  \n  $results = [System.Collections.Generic.List[object]]::new()\n  $successCount = 0\n  $failCount = 0\n  \n  # NTP epoch starts at 1900-01-01, Unix epoch at 1970-01-01\n  $ntpEpochDiff = [uint64]2208988800\n  \n  $serverIndex = 0\n  foreach ($server in $servers) {\n    $serverIndex++\n    Write-XYProgress (0.2 + (0.7 * $serverIndex / $servers.Count)) \"Querying $server...\"\n    \n    $serverResult = [ordered]@{\n      server = $server\n      success = $false\n      responseTime = $null\n      offset = $null\n      stratum = $null\n      referenceId = $null\n      serverTime = $null\n      localTime = $null\n      error = $null\n    }\n    \n    try {\n      # Resolve hostname to IP\n      $ip = [System.Net.Dns]::GetHostAddresses($server) | Where-Object { $_.AddressFamily -eq 'InterNetwork' } | Select-Object -First 1\n      if (-not $ip) { throw \"Could not resolve hostname\" }\n      \n      # Create UDP client\n      $udp = [System.Net.Sockets.UdpClient]::new()\n      $udp.Client.ReceiveTimeout = $timeout\n      $udp.Client.SendTimeout = $timeout\n      $endpoint = [System.Net.IPEndPoint]::new($ip, 123)\n      \n      # Build NTP request packet (48 bytes)\n      # LI=0, VN=4, Mode=3 (client) => 0x23\n      $ntpData = [byte[]]::new(48)\n      $ntpData[0] = 0x23\n      \n      # Record time before sending\n      $sw = [System.Diagnostics.Stopwatch]::StartNew()\n      $t1 = [DateTime]::UtcNow\n      \n      # Send request\n      $udp.Connect($endpoint)\n      $udp.Send($ntpData, $ntpData.Length) | Out-Null\n      \n      # Receive response\n      $remoteEP = [System.Net.IPEndPoint]::new([System.Net.IPAddress]::Any, 0)\n      $response = $udp.Receive([ref]$remoteEP)\n      $sw.Stop()\n      $t4 = [DateTime]::UtcNow\n      \n      $udp.Close()\n      \n      if ($response.Length -lt 48) { throw \"Invalid NTP response (too short)\" }\n      \n      # Parse response\n      $li = ($response[0] -band 0xC0) -shr 6\n      $vn = ($response[0] -band 0x38) -shr 3\n      $mode = $response[0] -band 0x07\n      $stratum = $response[1]\n      $poll = $response[2]\n      $precision = $response[3]\n      \n      # Reference ID (4 bytes at offset 12)\n      $refId = ''\n      if ($stratum -eq 0 -or $stratum -eq 1) {\n        # Stratum 0/1: ASCII identifier\n        $refId = [System.Text.Encoding]::ASCII.GetString($response, 12, 4).Trim([char]0)\n      } else {\n        # Stratum 2+: IP address of reference server\n        $refId = \"$($response[12]).$($response[13]).$($response[14]).$($response[15])\"\n      }\n      \n      # Transmit timestamp (seconds at offset 40, fraction at 44)\n      $txSeconds = ([uint64]$response[40] -shl 24) -bor ([uint64]$response[41] -shl 16) -bor ([uint64]$response[42] -shl 8) -bor [uint64]$response[43]\n      $txFraction = ([uint64]$response[44] -shl 24) -bor ([uint64]$response[45] -shl 16) -bor ([uint64]$response[46] -shl 8) -bor [uint64]$response[47]\n      \n      # Convert NTP timestamp to DateTime\n      $txUnix = [double]($txSeconds - $ntpEpochDiff) + ([double]$txFraction / [math]::Pow(2, 32))\n      $serverDateTime = [DateTimeOffset]::FromUnixTimeSeconds([long][math]::Floor($txUnix)).UtcDateTime.AddTicks([long](($txUnix % 1) * 10000000))\n      \n      # Calculate offset (simplified: server time - local time at reception)\n      $offsetMs = ($serverDateTime - $t4).TotalMilliseconds\n      \n      # Stratum description\n      $stratumDesc = switch ($stratum) {\n        0 { 'Unspecified/Invalid' }\n        1 { 'Primary (GPS, atomic clock)' }\n        { $_ -ge 2 -and $_ -le 15 } { \"Secondary (stratum $stratum)\" }\n        16 { 'Unsynchronized' }\n        default { \"Reserved ($stratum)\" }\n      }\n      \n      $serverResult.success = $true\n      $serverResult.responseTime = $sw.ElapsedMilliseconds\n      $serverResult.offset = [Math]::Round($offsetMs, 2)\n      $serverResult.stratum = $stratum\n      $serverResult.stratumDesc = $stratumDesc\n      $serverResult.referenceId = $refId\n      $serverResult.serverTime = $serverDateTime.ToString('yyyy-MM-dd HH:mm:ss.fff UTC')\n      $serverResult.localTime = $t4.ToString('yyyy-MM-dd HH:mm:ss.fff UTC')\n      $serverResult.version = $vn\n      $serverResult.leapIndicator = $li\n      $successCount++\n    } catch {\n      $serverResult.error = $_.Exception.Message\n      $failCount++\n    }\n    \n    $results.Add([pscustomobject]$serverResult)\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  # Build output tables\n  foreach ($r in $results) {\n    if ($r.success) {\n      $rows = @(\n        @('Server', $r.server),\n        @('Status', 'OK - Reachable'),\n        @('Response Time', \"$($r.responseTime)ms\"),\n        @('Server Time', $r.serverTime),\n        @('Local Time', $r.localTime),\n        @('Offset', \"$($r.offset)ms\"),\n        @('Stratum', \"$($r.stratum) - $($r.stratumDesc)\"),\n        @('Reference ID', $r.referenceId),\n        @('NTP Version', $r.version)\n      )\n      $offsetStatus = if ([Math]::Abs($r.offset) -lt 100) { 'Time is in sync' } elseif ([Math]::Abs($r.offset) -lt 1000) { 'Minor time drift detected' } else { 'Significant time drift!' }\n      Write-XY @{ table = @{ title=\"NTP Server - $($r.server)\"; header=@('Property','Value'); rows=$rows; caption=$offsetStatus } }\n    } else {\n      $rows = @(\n        @('Server', $r.server),\n        @('Status', 'FAIL - Unreachable'),\n        @('Error', $r.error)\n      )\n      Write-XY @{ table = @{ title=\"NTP Server - $($r.server)\"; header=@('Property','Value'); rows=$rows; caption='Failed to query NTP server' } }\n    }\n  }\n  \n  # Summary table if multiple servers\n  if ($servers.Count -gt 1) {\n    $summaryRows = @()\n    foreach ($r in $results) {\n      $status = if ($r.success) { 'OK' } else { 'FAIL' }\n      $offset = if ($r.success) { \"$($r.offset)ms\" } else { '-' }\n      $stratum = if ($r.success) { $r.stratum } else { '-' }\n      $rtt = if ($r.success) { \"$($r.responseTime)ms\" } else { '-' }\n      $summaryRows += ,@($r.server, $status, $rtt, $offset, $stratum)\n    }\n    Write-XY @{ table = @{ title='NTP Summary'; header=@('Server','Status','Response','Offset','Stratum'); rows=$summaryRows; caption=\"$successCount/$($servers.Count) servers reachable\" } }\n  }\n  \n  # Throw error if all servers failed\n  if ($successCount -eq 0) {\n    throw \"NTP check failed: All $($servers.Count) server(s) unreachable\"\n  }\n  \n  [pscustomobject]@{ tool='NTP Check'; serversChecked=$servers.Count; successful=$successCount; failed=$failCount; results=$results.ToArray() }\n}\n\n# ------------------------- WHOIS Lookup -------------------------\nfunction Invoke-WhoisLookup {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = Get-Param $Params 'whoisSource' 'field'\n  $domainsInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'whoisDataPath' ''\n    $domainsInput = Get-NestedValue $inputData $path\n    if ($null -eq $domainsInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $domainsInput = Get-Param $Params 'whoisDomains' '' }\n  \n  $domains = @(Get-MultipleInputs $domainsInput 10)\n  if ($domains.Count -eq 0) { throw 'No domain(s) specified' }\n  \n  # Clean domains\n  $domains = $domains | ForEach-Object { $_ -replace '^https?://', '' -replace '/.*$', '' -replace '^www\\.', '' }\n  \n  Write-XYProgress 0.2 \"Looking up WHOIS for $($domains.Count) domain(s)...\"\n  \n  $whoisServers = @{\n    'com'='whois.verisign-grs.com'; 'net'='whois.verisign-grs.com'; 'org'='whois.pir.org'\n    'io'='whois.nic.io'; 'co'='whois.nic.co'; 'me'='whois.nic.me'; 'info'='whois.afilias.net'\n    'biz'='whois.biz'; 'dev'='whois.nic.google'; 'app'='whois.nic.google'; 'uk'='whois.nic.uk'\n    'de'='whois.denic.de'; 'fr'='whois.nic.fr'; 'nl'='whois.domain-registry.nl'; 'eu'='whois.eu'; 'au'='whois.auda.org.au'\n  }\n  \n  $allResults = [System.Collections.Generic.List[object]]::new()\n  $totalSuccess = 0\n  $totalFail = 0\n  \n  $domainIndex = 0\n  foreach ($domain in $domains) {\n    $domainIndex++\n    Write-XYProgress (0.2 + (0.7 * $domainIndex / $domains.Count)) \"Looking up $domain...\"\n    \n    $whoisData = @{}; $rawResponse = ''; $success = $true; $errorMsg = ''\n    \n    try {\n      $tld = ($domain -split '\\.')[-1].ToLower()\n      $whoisServer = if ($whoisServers.ContainsKey($tld)) { $whoisServers[$tld] } else { 'whois.iana.org' }\n      \n      $client = [System.Net.Sockets.TcpClient]::new($whoisServer, 43)\n      $stream = $client.GetStream(); $writer = [System.IO.StreamWriter]::new($stream); $reader = [System.IO.StreamReader]::new($stream)\n      $writer.WriteLine($domain); $writer.Flush(); $rawResponse = $reader.ReadToEnd()\n      $reader.Close(); $writer.Close(); $client.Close()\n      \n      $patterns = @{ 'Registrar'='Registrar:\\s*(.+)'; 'Expiration Date'='(Expir[ey]|Registry Expiry Date).*?:\\s*(.+)' }\n      foreach ($key in $patterns.Keys) {\n        $regMatches = [regex]::Matches($rawResponse, $patterns[$key], 'IgnoreCase,Multiline')\n        if ($regMatches.Count -gt 0) { $whoisData[$key] = ($regMatches | ForEach-Object { $_.Groups[$_.Groups.Count - 1].Value.Trim() } | Select-Object -First 1) }\n      }\n      $totalSuccess++\n    } catch {\n      $success = $false\n      $errorMsg = $_.Exception.Message\n      $totalFail++\n    }\n    \n    if ($success) {\n      $summaryRows = @(@('Domain', $domain))\n      if ($whoisData['Registrar']) { $summaryRows += ,@('Registrar', $whoisData['Registrar']) }\n      if ($whoisData['Expiration Date']) { $summaryRows += ,@('Expiration', $whoisData['Expiration Date']) }\n      Write-XY @{ table = @{ title=\"WHOIS - $domain\"; header=@('Property','Value'); rows=$summaryRows; caption='Lookup successful' } }\n      $allResults.Add([pscustomobject]@{ domain=$domain; success=$true; registrar=$whoisData['Registrar']; expirationDate=$whoisData['Expiration Date'] })\n    } else {\n      Write-XY @{ table = @{ title=\"WHOIS - $domain\"; header=@('Property','Value'); rows=@(@('Domain', $domain), @('Error', $errorMsg)); caption='Lookup failed' } }\n      $allResults.Add([pscustomobject]@{ domain=$domain; success=$false; error=$errorMsg })\n    }\n  }\n  \n  if ($domains.Count -gt 1) {\n    $summaryRows = @()\n    foreach ($r in $allResults) {\n      $status = if ($r.success) { 'OK' } else { 'FAIL' }\n      $expiry = if ($r.success -and $r.expirationDate) { $r.expirationDate.Substring(0, [Math]::Min(10, $r.expirationDate.Length)) } else { '-' }\n      $summaryRows += ,@($r.domain, $status, $expiry)\n    }\n    Write-XY @{ table = @{ title='WHOIS Summary'; header=@('Domain','Status','Expiry'); rows=$summaryRows; caption=\"$totalSuccess/$($domains.Count) lookups successful\" } }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  [pscustomobject]@{ tool='WHOIS Lookup'; domainsChecked=$domains.Count; successful=$totalSuccess; failed=$totalFail; results=$allResults.ToArray() }\n}\n\n# ------------------------- Network Scanner -------------------------\nfunction Invoke-NetworkScanner {\n  param($Params, $JobInput)\n  Write-XYProgress 0.05 'Validating parameters...'\n  \n  $source = Get-Param $Params 'netScanSource' 'field'\n  $networksInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'netScanDataPath' ''\n    $networksInput = Get-NestedValue $inputData $path\n    if ($null -eq $networksInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $networksInput = Get-Param $Params 'netScanNetworks' '' }\n  \n  $networks = @(Get-MultipleInputs $networksInput 10)\n  if ($networks.Count -eq 0) { throw 'No network(s) specified' }\n  \n  $timeout = [Math]::Min(5000, [Math]::Max(100, [int](Get-Param $Params 'netScanTimeout' 500)))\n  $maxConcurrent = 25\n  $commonPorts = @(22, 80, 443, 3389, 445)\n  \n  # Helper: Convert CIDR to IP list\n  function Get-IPsFromCIDR {\n    param([string]$CIDR)\n    if ($CIDR -notmatch '^(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})/(\\d{1,2})$') {\n      throw \"Invalid CIDR format: $CIDR (expected format: 192.168.1.0/24)\"\n    }\n    $ipPart = $Matches[1]\n    $prefix = [int]$Matches[2]\n    \n    if ($prefix -lt 22) { throw \"Network too large: /$prefix. Maximum allowed is /22 (1024 hosts)\" }\n    if ($prefix -gt 32) { throw \"Invalid prefix: /$prefix\" }\n    \n    $ipBytes = [System.Net.IPAddress]::Parse($ipPart).GetAddressBytes()\n    [Array]::Reverse($ipBytes)\n    $ipInt = [BitConverter]::ToUInt32($ipBytes, 0)\n    \n    $hostBits = 32 - $prefix\n    $numHosts = [Math]::Pow(2, $hostBits)\n    $networkInt = $ipInt -band ([uint32]::MaxValue -shl $hostBits)\n    \n    $ips = [System.Collections.Generic.List[string]]::new()\n    for ($i = 1; $i -lt ($numHosts - 1); $i++) {\n      $currentInt = $networkInt + $i\n      $bytes = [BitConverter]::GetBytes([uint32]$currentInt)\n      [Array]::Reverse($bytes)\n      $ips.Add(([System.Net.IPAddress]::new($bytes)).ToString())\n    }\n    return $ips\n  }\n  \n  # Helper: Check single host (ping + port fallback)\n  $checkHostScript = {\n    param($IP, $Timeout, $Ports)\n    $result = @{ IP = $IP; Active = $false; Method = ''; ResponseTime = $null; Hostname = ''; MAC = '' }\n    \n    # Try ping first\n    try {\n      $pinger = [System.Net.NetworkInformation.Ping]::new()\n      $reply = $pinger.Send($IP, $Timeout)\n      if ($reply.Status -eq 'Success') {\n        $result.Active = $true\n        $result.Method = 'ICMP'\n        $result.ResponseTime = $reply.RoundtripTime\n      }\n      $pinger.Dispose()\n    } catch { }\n    \n    # If ping failed, try common ports\n    if (-not $result.Active) {\n      foreach ($port in $Ports) {\n        try {\n          $client = [System.Net.Sockets.TcpClient]::new()\n          $task = $client.BeginConnect($IP, $port, $null, $null)\n          $success = $task.AsyncWaitHandle.WaitOne($Timeout, $false)\n          if ($success -and $client.Connected) {\n            $result.Active = $true\n            $result.Method = \"TCP/$port\"\n            $client.Close()\n            break\n          }\n          $client.Close()\n        } catch { }\n      }\n    }\n    \n    # Resolve hostname if active\n    if ($result.Active) {\n      try {\n        $hostEntry = [System.Net.Dns]::GetHostEntry($IP)\n        $result.Hostname = $hostEntry.HostName\n      } catch { $result.Hostname = '-' }\n    }\n    \n    return $result\n  }\n  \n  Write-XYProgress 0.1 \"Parsing $($networks.Count) network(s)...\"\n  \n  $allResults = [System.Collections.Generic.List[object]]::new()\n  $grandTotalActive = 0\n  $grandTotalScanned = 0\n  \n  $networkIndex = 0\n  foreach ($network in $networks) {\n    $networkIndex++\n    Write-XYProgress (0.1 + (0.05 * $networkIndex / $networks.Count)) \"Parsing $network...\"\n    \n    $networkResult = @{ network = $network; hosts = [System.Collections.Generic.List[object]]::new(); error = $null }\n    \n    try {\n      $ips = @(Get-IPsFromCIDR $network)\n      $totalIPs = $ips.Count\n      $grandTotalScanned += $totalIPs\n      \n      Write-XYProgress 0.15 \"Scanning $totalIPs hosts in $network (25 concurrent)...\"\n      \n      # Create runspace pool for parallel execution\n      $runspacePool = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspacePool(1, $maxConcurrent)\n      $runspacePool.Open()\n      \n      $jobs = [System.Collections.Generic.List[object]]::new()\n      \n      # Queue all IP scans\n      foreach ($ip in $ips) {\n        $ps = [PowerShell]::Create().AddScript($checkHostScript).AddArgument($ip).AddArgument($timeout).AddArgument($commonPorts)\n        $ps.RunspacePool = $runspacePool\n        $jobs.Add(@{ PS = $ps; Handle = $ps.BeginInvoke(); IP = $ip })\n      }\n      \n      # Collect results with progress updates\n      $completed = 0\n      $activeCount = 0\n      $hostResults = [System.Collections.Generic.List[object]]::new()\n      \n      foreach ($job in $jobs) {\n        try {\n          $r = $job.PS.EndInvoke($job.Handle)\n          if ($r -and $r.Active) {\n            $activeCount++\n            $hostResults.Add([pscustomobject]$r)\n          }\n        } catch { }\n        $job.PS.Dispose()\n        $completed++\n        \n        if ($completed % 50 -eq 0 -or $completed -eq $totalIPs) {\n          $pct = 0.15 + (0.75 * ($networkIndex - 1 + ($completed / $totalIPs)) / $networks.Count)\n          Write-XYProgress $pct \"Scanned $completed/$totalIPs in $network ($activeCount active)...\"\n        }\n      }\n      \n      $runspacePool.Close()\n      $runspacePool.Dispose()\n      \n      # Try to get MAC addresses from ARP cache (local subnet only)\n      try {\n        $arpOutput = & arp -a 2>$null\n        $arpTable = @{}\n        foreach ($line in $arpOutput) {\n          if ($line -match '(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\\s+([0-9a-fA-F:-]{11,17})') {\n            $arpTable[$Matches[1]] = $Matches[2].ToUpper() -replace '-', ':'\n          }\n        }\n        foreach ($h in $hostResults) {\n          if ($arpTable.ContainsKey($h.IP)) { $h.MAC = $arpTable[$h.IP] }\n          else { $h.MAC = '-' }\n        }\n      } catch { }\n      \n      $grandTotalActive += $activeCount\n      $networkResult.hosts = $hostResults\n      $networkResult.totalScanned = $totalIPs\n      $networkResult.activeCount = $activeCount\n      \n      # Output table for this network\n      if ($hostResults.Count -gt 0) {\n        $rows = @()\n        foreach ($h in ($hostResults | Sort-Object { [System.Version]$_.IP })) {\n          $rt = if ($null -ne $h.ResponseTime) { \"$($h.ResponseTime)ms\" } else { '-' }\n          $rows += ,@($h.IP, $h.Hostname, $h.Method, $rt, $h.MAC)\n        }\n        Write-XY @{ table = @{ title=\"Active Hosts - $network\"; header=@('IP','Hostname','Method','Response','MAC'); rows=$rows; caption=\"$activeCount active hosts found\" } }\n      } else {\n        Write-XY @{ table = @{ title=\"Network Scan - $network\"; header=@('Result'); rows=@(,@('No active hosts found')); caption=\"Scanned $totalIPs hosts\" } }\n      }\n      \n    } catch {\n      $networkResult.error = $_.Exception.Message\n      Write-XY @{ table = @{ title=\"Network Scan - $network\"; header=@('Error'); rows=@(,@($_.Exception.Message)); caption='Scan failed' } }\n    }\n    \n    $allResults.Add([pscustomobject]$networkResult)\n  }\n  \n  # Summary if multiple networks\n  if ($networks.Count -gt 1) {\n    $summaryRows = @()\n    foreach ($r in $allResults) {\n      $status = if ($r.error) { 'ERROR' } else { 'OK' }\n      $active = if ($r.error) { '-' } else { $r.activeCount }\n      $scanned = if ($r.error) { '-' } else { $r.totalScanned }\n      $summaryRows += ,@($r.network, $status, $scanned, $active)\n    }\n    Write-XY @{ table = @{ title='Network Scan Summary'; header=@('Network','Status','Scanned','Active'); rows=$summaryRows; caption=\"Total: $grandTotalActive active hosts in $grandTotalScanned scanned\" } }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  # Build output with all active hosts for easy bucket use\n  $allActiveHosts = @()\n  $allActiveIPs = @()\n  foreach ($r in $allResults) {\n    if ($r.hosts) {\n      foreach ($h in $r.hosts) {\n        $allActiveHosts += $h\n        $allActiveIPs += $h.IP\n      }\n    }\n  }\n  \n  [pscustomobject]@{\n    tool = 'Network Scanner'\n    networksScanned = $networks.Count\n    totalHostsScanned = $grandTotalScanned\n    totalActiveHosts = $grandTotalActive\n    activeIPs = $allActiveIPs\n    results = $allResults.ToArray()\n    hosts = $allActiveHosts\n  }\n}\n\n# ------------------------- Wake-on-LAN -------------------------\nfunction Invoke-WakeOnLan {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = Get-Param $Params 'wolSource' 'field'\n  $devicesInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'wolDataPath' ''\n    $devicesInput = Get-NestedValue $inputData $path\n    if ($null -eq $devicesInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $devicesInput = Get-Param $Params 'wolMacAddresses' '' }\n  \n  $devices = @(Get-MultipleInputs $devicesInput 50)\n  if ($devices.Count -eq 0) { throw 'No device(s) specified' }\n  \n  $broadcastIP = Get-Param $Params 'wolBroadcast' '255.255.255.255'\n  $port = [int](Get-Param $Params 'wolPort' 9)\n  \n  Write-XYProgress 0.2 \"Sending Wake-on-LAN to $($devices.Count) device(s)...\"\n  \n  $results = [System.Collections.Generic.List[object]]::new()\n  $successCount = 0\n  \n  foreach ($device in $devices) {\n    $mac = $device.Trim().ToUpper() -replace '[:-]', ''\n    $success = $false\n    $errorMsg = ''\n    \n    try {\n      if ($mac -notmatch '^[0-9A-F]{12}$') { throw \"Invalid MAC format: $device\" }\n      \n      # Build magic packet: 6x FF + 16x MAC\n      $macBytes = [byte[]]::new(6)\n      for ($i = 0; $i -lt 6; $i++) { $macBytes[$i] = [Convert]::ToByte($mac.Substring($i * 2, 2), 16) }\n      \n      $packet = [byte[]]::new(102)\n      for ($i = 0; $i -lt 6; $i++) { $packet[$i] = 0xFF }\n      for ($i = 0; $i -lt 16; $i++) { [Array]::Copy($macBytes, 0, $packet, 6 + ($i * 6), 6) }\n      \n      $udpClient = [System.Net.Sockets.UdpClient]::new()\n      $udpClient.EnableBroadcast = $true\n      $udpClient.Send($packet, $packet.Length, $broadcastIP, $port) | Out-Null\n      $udpClient.Close()\n      \n      $success = $true\n      $successCount++\n    } catch {\n      $errorMsg = $_.Exception.Message\n    }\n    \n    $formattedMac = ($mac -replace '(.{2})', '$1:').TrimEnd(':')\n    $results.Add([pscustomobject]@{ mac = $formattedMac; sent = $success; error = $errorMsg })\n  }\n  \n  # Output table\n  $rows = @()\n  foreach ($r in $results) {\n    $status = if ($r.sent) { 'Sent' } else { \"Failed: $($r.error)\" }\n    $rows += ,@($r.mac, $status)\n  }\n  Write-XY @{ table = @{ title='Wake-on-LAN Results'; header=@('MAC Address','Status'); rows=$rows; caption=\"$successCount/$($devices.Count) packets sent to $broadcastIP`:$port\" } }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  [pscustomobject]@{ tool='Wake-on-LAN'; deviceCount=$devices.Count; sent=$successCount; broadcast=$broadcastIP; port=$port; results=$results.ToArray() }\n}\n\n# ------------------------- Subnet Calculator -------------------------\nfunction Invoke-SubnetCalculator {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $mode = Get-Param $Params 'subnetMode' 'calculate'\n  $cidrInput = Get-Param $Params 'subnetCidr' ''\n  \n  if (-not $cidrInput) { throw 'No network/CIDR specified' }\n  \n  Write-XYProgress 0.3 'Calculating subnet details...'\n  \n  # Helper functions\n  function ConvertTo-IPInt { param([string]$IP) $b = [System.Net.IPAddress]::Parse($IP).GetAddressBytes(); [Array]::Reverse($b); [BitConverter]::ToUInt32($b, 0) }\n  function ConvertTo-IPString { param([uint32]$Int) $b = [BitConverter]::GetBytes($Int); [Array]::Reverse($b); ([System.Net.IPAddress]::new($b)).ToString() }\n  function ConvertTo-Binary { param([string]$IP) ($IP -split '\\.' | ForEach-Object { [Convert]::ToString([int]$_, 2).PadLeft(8, '0') }) -join '.' }\n  \n  $result = @{ tool = 'Subnet Calculator'; mode = $mode }\n  \n  if ($mode -eq 'vlsm') {\n    # VLSM mode: split network into subnets\n    $vlsmInput = Get-Param $Params 'subnetVlsmRequirements' ''\n    if (-not $vlsmInput) { throw 'No VLSM host requirements specified' }\n    \n    if ($cidrInput -notmatch '^(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})/(\\d{1,2})$') { throw 'Invalid CIDR format' }\n    $baseIP = $Matches[1]; $basePrefix = [int]$Matches[2]\n    $baseInt = ConvertTo-IPInt $baseIP\n    $totalHosts = [Math]::Pow(2, 32 - $basePrefix)\n    \n    # Parse host requirements (comma-separated)\n    $requirements = @($vlsmInput -split '[,;\\n]+' | ForEach-Object { [int]$_.Trim() } | Where-Object { $_ -gt 0 } | Sort-Object -Descending)\n    \n    $subnets = [System.Collections.Generic.List[object]]::new()\n    $currentInt = $baseInt\n    $usedHosts = 0\n    \n    foreach ($needed in $requirements) {\n      $hostBits = [Math]::Ceiling([Math]::Log($needed + 2, 2))\n      $subnetSize = [Math]::Pow(2, $hostBits)\n      $prefix = 32 - $hostBits\n      \n      if ($usedHosts + $subnetSize -gt $totalHosts) {\n        $subnets.Add([pscustomobject]@{ network = 'INSUFFICIENT SPACE'; prefix = '-'; hosts = $needed; usable = '-' })\n        continue\n      }\n      \n      $networkAddr = ConvertTo-IPString $currentInt\n      $broadcast = ConvertTo-IPString ($currentInt + $subnetSize - 1)\n      $firstHost = ConvertTo-IPString ($currentInt + 1)\n      $lastHost = ConvertTo-IPString ($currentInt + $subnetSize - 2)\n      \n      $subnets.Add([pscustomobject]@{ network = \"$networkAddr/$prefix\"; needed = $needed; usable = ($subnetSize - 2); first = $firstHost; last = $lastHost; broadcast = $broadcast })\n      \n      $currentInt += $subnetSize\n      $usedHosts += $subnetSize\n    }\n    \n    $rows = @()\n    foreach ($s in $subnets) { $rows += ,@($s.network, $s.needed, $s.usable, $s.first, $s.last) }\n    Write-XY @{ table = @{ title=\"VLSM Subnets for $cidrInput\"; header=@('Subnet','Needed','Usable','First Host','Last Host'); rows=$rows; caption=\"$($subnets.Count) subnets created\" } }\n    \n    $result.subnets = $subnets.ToArray()\n  }\n  else {\n    # Standard calculate mode\n    if ($cidrInput -notmatch '^(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})/(\\d{1,2})$') { throw 'Invalid CIDR format' }\n    $ip = $Matches[1]; $prefix = [int]$Matches[2]\n    \n    $ipInt = ConvertTo-IPInt $ip\n    $hostBits = 32 - $prefix\n    $numHosts = [Math]::Pow(2, $hostBits)\n    $maskInt = [uint32]::MaxValue -shl $hostBits\n    $networkInt = $ipInt -band $maskInt\n    $broadcastInt = $networkInt + $numHosts - 1\n    \n    $networkAddr = ConvertTo-IPString $networkInt\n    $broadcastAddr = ConvertTo-IPString $broadcastInt\n    $firstHost = if ($numHosts -gt 2) { ConvertTo-IPString ($networkInt + 1) } else { 'N/A' }\n    $lastHost = if ($numHosts -gt 2) { ConvertTo-IPString ($broadcastInt - 1) } else { 'N/A' }\n    $subnetMask = ConvertTo-IPString $maskInt\n    $wildcardMask = ConvertTo-IPString ([uint32]::MaxValue -bxor $maskInt)\n    $usableHosts = if ($numHosts -gt 2) { $numHosts - 2 } else { 0 }\n    \n    $rows = @(\n      @('CIDR Notation', $cidrInput),\n      @('Network Address', $networkAddr),\n      @('Broadcast Address', $broadcastAddr),\n      @('Subnet Mask', $subnetMask),\n      @('Wildcard Mask', $wildcardMask),\n      @('First Usable Host', $firstHost),\n      @('Last Usable Host', $lastHost),\n      @('Total Addresses', $numHosts),\n      @('Usable Hosts', $usableHosts),\n      @('Network Binary', (ConvertTo-Binary $networkAddr)),\n      @('Mask Binary', (ConvertTo-Binary $subnetMask))\n    )\n    Write-XY @{ table = @{ title='Subnet Details'; header=@('Property','Value'); rows=$rows; caption='' } }\n    \n    $result += @{ cidr=$cidrInput; network=$networkAddr; broadcast=$broadcastAddr; subnetMask=$subnetMask; wildcardMask=$wildcardMask; firstHost=$firstHost; lastHost=$lastHost; totalAddresses=$numHosts; usableHosts=$usableHosts }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  [pscustomobject]$result\n}\n\n# ------------------------- IP Geolocation -------------------------\nfunction Invoke-IPGeolocation {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = Get-Param $Params 'geoSource' 'field'\n  $ipsInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'geoDataPath' ''\n    $ipsInput = Get-NestedValue $inputData $path\n    if ($null -eq $ipsInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $ipsInput = Get-Param $Params 'geoIpAddresses' '' }\n  \n  $ips = @(Get-MultipleInputs $ipsInput 20)\n  if ($ips.Count -eq 0) { throw 'No IP address(es) specified' }\n  \n  Write-XYProgress 0.2 \"Looking up geolocation for $($ips.Count) IP(s)...\"\n  \n  $results = [System.Collections.Generic.List[object]]::new()\n  $ipIndex = 0\n  \n  foreach ($ip in $ips) {\n    $ipIndex++\n    Write-XYProgress (0.2 + (0.7 * $ipIndex / $ips.Count)) \"Looking up $ip...\"\n    \n    $geoData = @{ ip = $ip; success = $false }\n    \n    try {\n      $response = Invoke-RestMethod -Uri \"http://ip-api.com/json/$($ip)?fields=status,message,country,countryCode,region,regionName,city,zip,lat,lon,timezone,isp,org,as,query\" -TimeoutSec 10 -UserAgent 'xyOps-Network/1.0'\n      \n      if ($response.status -eq 'success') {\n        $geoData.success = $true\n        $geoData.country = $response.country\n        $geoData.countryCode = $response.countryCode\n        $geoData.region = $response.regionName\n        $geoData.city = $response.city\n        $geoData.zip = $response.zip\n        $geoData.latitude = $response.lat\n        $geoData.longitude = $response.lon\n        $geoData.timezone = $response.timezone\n        $geoData.isp = $response.isp\n        $geoData.org = $response.org\n        $geoData.asn = $response.as\n        \n        $rows = @(\n          @('IP Address', $ip),\n          @('Country', \"$($response.country) ($($response.countryCode))\"),\n          @('Region', $response.regionName),\n          @('City', $response.city),\n          @('ZIP/Postal', $response.zip),\n          @('Coordinates', \"$($response.lat), $($response.lon)\"),\n          @('Timezone', $response.timezone),\n          @('ISP', $response.isp),\n          @('Organization', $response.org),\n          @('ASN', $response.as)\n        )\n        Write-XY @{ table = @{ title=\"Geolocation - $ip\"; header=@('Property','Value'); rows=$rows; caption='' } }\n      } else {\n        $geoData.error = $response.message\n        Write-XY @{ table = @{ title=\"Geolocation - $ip\"; header=@('Property','Value'); rows=@(@('Error', $response.message)); caption='Lookup failed' } }\n      }\n    } catch {\n      $geoData.error = $_.Exception.Message\n      Write-XY @{ table = @{ title=\"Geolocation - $ip\"; header=@('Property','Value'); rows=@(@('Error', $_.Exception.Message)); caption='Lookup failed' } }\n    }\n    \n    $results.Add([pscustomobject]$geoData)\n    \n    # Rate limit: ip-api allows 45 requests per minute for free\n    if ($ipIndex -lt $ips.Count) { Start-Sleep -Milliseconds 1500 }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  [pscustomobject]@{ tool='IP Geolocation'; ipsChecked=$ips.Count; results=$results.ToArray() }\n}\n\n# ------------------------- SPF/DKIM/DMARC Checker -------------------------\nfunction Invoke-EmailAuthChecker {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = Get-Param $Params 'emailAuthSource' 'field'\n  $domainsInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'emailAuthDataPath' ''\n    $domainsInput = Get-NestedValue $inputData $path\n    if ($null -eq $domainsInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $domainsInput = Get-Param $Params 'emailAuthDomains' '' }\n  \n  $domains = @(Get-MultipleInputs $domainsInput 10)\n  if ($domains.Count -eq 0) { throw 'No domain(s) specified' }\n  \n  $dkimSelector = Get-Param $Params 'emailAuthDkimSelector' 'default'\n  $dnsMode = Get-Param $Params 'emailAuthDnsMode' 'internal'\n  $externalDns = Get-Param $Params 'emailAuthExternalDns' '1.1.1.1'\n  $dnsServer = if ($dnsMode -eq 'external') { $externalDns } else { $null }\n  \n  # Test external DNS connectivity if external mode is selected\n  if ($dnsServer) {\n    Write-XYProgress 0.15 \"Testing connectivity to external DNS server $dnsServer...\"\n    try {\n      $null = Resolve-DnsName -Name 'cloudflare.com' -Type A -Server $dnsServer -ErrorAction Stop -DnsOnly\n    } catch {\n      throw \"Cannot reach external DNS server '$dnsServer'. A firewall rule may be required to allow outbound DNS (UDP/TCP port 53) to this server. Error: $($_.Exception.Message)\"\n    }\n  }\n  \n  Write-XYProgress 0.2 \"Checking email authentication for $($domains.Count) domain(s)$(if ($dnsServer) { \" using DNS $dnsServer\" } else { '' })...\"\n  \n  $results = [System.Collections.Generic.List[object]]::new()\n  \n  foreach ($domain in $domains) {\n    $domain = $domain -replace '^https?://', '' -replace '/.*$', '' -replace '^www\\.', ''\n    Write-XYProgress 0.3 \"Checking $domain...\"\n    \n    $domainResult = @{ domain = $domain; spf = @{}; dkim = @{}; dmarc = @{}; score = 0; grade = 'F'; recommendations = @() }\n    $score = 0\n    $recommendations = [System.Collections.Generic.List[string]]::new()\n    \n    # Check SPF\n    try {\n      $dnsParams = @{ Name = $domain; Type = 'TXT'; ErrorAction = 'Stop' }\n      if ($dnsServer) { $dnsParams.Server = $dnsServer }\n      $allRecords = @(Resolve-DnsName @dnsParams)\n      $txtRecords = @($allRecords | Where-Object { $null -ne $_.Strings })\n      $spfRecords = @()\n      foreach ($rec in $txtRecords) {\n        $txtValue = if ($rec.Strings -is [array]) { $rec.Strings -join '' } else { [string]$rec.Strings }\n        if ($txtValue -match '^v=spf1') { $spfRecords += @{ record = $txtValue } }\n      }\n      \n      if ($spfRecords.Count -gt 0) {\n        $spfRecord = $spfRecords[0].record\n        if ($spfRecords.Count -gt 1) { $recommendations.Add(\"SPF: WARNING - Multiple SPF records found ($($spfRecords.Count)). Only one SPF record should exist per domain!\") }\n        $domainResult.spf.exists = $true\n        $domainResult.spf.record = $spfRecord\n        $score += 25\n        \n        # Validate SPF\n        if ($spfRecord -match '-all$') { $domainResult.spf.policy = 'Strict (-all)'; $score += 5 }\n        elseif ($spfRecord -match '~all$') { $domainResult.spf.policy = 'Soft fail (~all)'; $score += 3 }\n        elseif ($spfRecord -match '\\?all$') { $domainResult.spf.policy = 'Neutral (?all)'; $recommendations.Add('SPF: Use -all or ~all instead of ?all') }\n        elseif ($spfRecord -match '\\+all$') { $domainResult.spf.policy = 'Allow all (+all)'; $recommendations.Add('SPF: CRITICAL - +all allows anyone to send as your domain!') }\n        else { $recommendations.Add('SPF: Add -all or ~all at the end') }\n        \n        $lookups = ([regex]::Matches($spfRecord, '(include:|a:|mx:|ptr:|exists:)')).Count\n        $domainResult.spf.lookups = $lookups\n        if ($lookups -gt 10) { $recommendations.Add(\"SPF: Too many DNS lookups ($lookups/10 max)\") }\n      } else {\n        $domainResult.spf.exists = $false\n        $recommendations.Add('SPF: No SPF record found - add one to prevent spoofing')\n      }\n    } catch { $domainResult.spf.exists = $false; $domainResult.spf.error = $_.Exception.Message }\n    \n    # Check DKIM\n    try {\n      $dkimName = \"$dkimSelector._domainkey.$domain\"\n      $dkimDnsParams = @{ Name = $dkimName; Type = 'TXT'; ErrorAction = 'Stop' }\n      if ($dnsServer) { $dkimDnsParams.Server = $dnsServer }\n      $dkimRecords = @(Resolve-DnsName @dkimDnsParams)\n      if ($dkimRecords.Count -gt 0) {\n        $dkimRecord = $dkimRecords[0].Strings -join ''\n        $domainResult.dkim.exists = $true\n        $domainResult.dkim.selector = $dkimSelector\n        $domainResult.dkim.record = if ($dkimRecord.Length -gt 100) { $dkimRecord.Substring(0, 100) + '...' } else { $dkimRecord }\n        $score += 25\n        \n        if ($dkimRecord -match 'k=rsa') { $domainResult.dkim.keyType = 'RSA' }\n        if ($dkimRecord -match 'p=([A-Za-z0-9+/=]+)') {\n          $keyLength = $Matches[1].Length * 6 / 8 * 8\n          $domainResult.dkim.keyLength = \"~$keyLength bits\"\n          if ($keyLength -lt 1024) { $recommendations.Add('DKIM: Key length should be at least 1024 bits') }\n        }\n      } else {\n        $domainResult.dkim.exists = $false\n        $recommendations.Add(\"DKIM: No record found for selector '$dkimSelector'\")\n      }\n    } catch { $domainResult.dkim.exists = $false; $domainResult.dkim.error = 'Not found or error' }\n    \n    # Check DMARC\n    try {\n      $dmarcName = \"_dmarc.$domain\"\n      $dmarcDnsParams = @{ Name = $dmarcName; Type = 'TXT'; ErrorAction = 'Stop' }\n      if ($dnsServer) { $dmarcDnsParams.Server = $dnsServer }\n      $dmarcTxtRecords = @(Resolve-DnsName @dmarcDnsParams | Where-Object { $_.QueryType -eq 'TXT' -and $null -ne $_.Strings })\n      $dmarcRecords = @($dmarcTxtRecords | Where-Object { ($_.Strings -join '') -match '^v=DMARC1' })\n      if ($dmarcRecords.Count -gt 0) {\n        $dmarcRecord = $dmarcRecords[0].Strings -join ''\n        $domainResult.dmarc.exists = $true\n        $domainResult.dmarc.record = $dmarcRecord\n        $score += 25\n        \n        if ($dmarcRecord -match 'p=(none|quarantine|reject)') {\n          $policy = $Matches[1]\n          $domainResult.dmarc.policy = $policy\n          if ($policy -eq 'reject') { $score += 10 }\n          elseif ($policy -eq 'quarantine') { $score += 5 }\n          else { $recommendations.Add('DMARC: Consider upgrading policy from none to quarantine or reject') }\n        }\n        if ($dmarcRecord -match 'rua=([^;]+)') { $domainResult.dmarc.reportUri = $Matches[1]; $score += 5 }\n        else { $recommendations.Add('DMARC: Add rua= to receive aggregate reports') }\n        if ($dmarcRecord -match 'pct=(\\d+)') { $domainResult.dmarc.percentage = [int]$Matches[1] }\n      } else {\n        $domainResult.dmarc.exists = $false\n        $recommendations.Add('DMARC: No DMARC record found - add one for policy enforcement')\n      }\n    } catch { $domainResult.dmarc.exists = $false; $domainResult.dmarc.error = $_.Exception.Message }\n    \n    # Calculate grade\n    $grade = if ($score -ge 90) { 'A' } elseif ($score -ge 75) { 'B' } elseif ($score -ge 60) { 'C' } elseif ($score -ge 40) { 'D' } else { 'F' }\n    $domainResult.score = $score\n    $domainResult.grade = $grade\n    $domainResult.recommendations = $recommendations.ToArray()\n    \n    # Output tables\n    $summaryRows = @(\n      @('Domain', $domain),\n      @('Score', \"$score/100\"),\n      @('Grade', $grade),\n      @('SPF', $(if ($domainResult.spf.exists) { 'Found' } else { 'Missing' })),\n      @('DKIM', $(if ($domainResult.dkim.exists) { 'Found' } else { 'Missing' })),\n      @('DMARC', $(if ($domainResult.dmarc.exists) { 'Found' } else { 'Missing' }))\n    )\n    Write-XY @{ table = @{ title=\"Email Auth Summary - $domain\"; header=@('Property','Value'); rows=$summaryRows; caption=\"Grade: $grade\" } }\n    \n    if ($domainResult.spf.exists) {\n      Write-XY @{ table = @{ title=\"SPF Record\"; header=@('Property','Value'); rows=@(@('Record', $domainResult.spf.record), @('Policy', $domainResult.spf.policy), @('DNS Lookups', $domainResult.spf.lookups)); caption='' } }\n    }\n    if ($domainResult.dmarc.exists) {\n      Write-XY @{ table = @{ title=\"DMARC Record\"; header=@('Property','Value'); rows=@(@('Record', $domainResult.dmarc.record), @('Policy', $domainResult.dmarc.policy)); caption='' } }\n    }\n    if ($recommendations.Count -gt 0) {\n      $recRows = @(); foreach ($r in $recommendations) { $recRows += ,@($r) }\n      Write-XY @{ table = @{ title=\"Recommendations\"; header=@('Action'); rows=$recRows; caption='' } }\n    }\n    \n    $results.Add([pscustomobject]$domainResult)\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  [pscustomobject]@{ tool='Email Auth Checker'; domainsChecked=$domains.Count; results=$results.ToArray() }\n}\n\n# ------------------------- Blacklist Checker -------------------------\nfunction Invoke-BlacklistChecker {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = Get-Param $Params 'blSource' 'field'\n  $targetsInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'blDataPath' ''\n    $targetsInput = Get-NestedValue $inputData $path\n    if ($null -eq $targetsInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $targetsInput = Get-Param $Params 'blTargets' '' }\n  \n  $targets = @(Get-MultipleInputs $targetsInput 10)\n  if ($targets.Count -eq 0) { throw 'No IP(s) or domain(s) specified' }\n  \n  Write-XYProgress 0.2 \"Checking $($targets.Count) target(s) against blacklists...\"\n  \n  # Common DNSBL servers\n  $ipBlacklists = @(\n    @{ name = 'Spamhaus ZEN'; zone = 'zen.spamhaus.org' },\n    @{ name = 'Barracuda'; zone = 'b.barracudacentral.org' },\n    @{ name = 'SpamCop'; zone = 'bl.spamcop.net' },\n    @{ name = 'SORBS'; zone = 'dnsbl.sorbs.net' },\n    @{ name = 'Composite BL'; zone = 'cbl.abuseat.org' },\n    @{ name = 'UCEPROTECT-1'; zone = 'dnsbl-1.uceprotect.net' },\n    @{ name = 'Spam Rats'; zone = 'noptr.spamrats.com' }\n  )\n  \n  $domainBlacklists = @(\n    @{ name = 'Spamhaus DBL'; zone = 'dbl.spamhaus.org' },\n    @{ name = 'SURBL'; zone = 'multi.surbl.org' },\n    @{ name = 'URIBL'; zone = 'multi.uribl.com' }\n  )\n  \n  $results = [System.Collections.Generic.List[object]]::new()\n  \n  foreach ($target in $targets) {\n    $target = $target.Trim()\n    $isIP = $target -match '^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$'\n    $targetResult = @{ target = $target; type = $(if ($isIP) { 'IP' } else { 'Domain' }); listings = @(); listedCount = 0; checkedCount = 0 }\n    \n    $blacklists = if ($isIP) { $ipBlacklists } else { $domainBlacklists }\n    $queryTarget = if ($isIP) { ($target -split '\\.' | ForEach-Object -Begin { $a = @() } -Process { $a = ,$_ + $a } -End { $a -join '.' }) } else { $target }\n    \n    foreach ($bl in $blacklists) {\n      $targetResult.checkedCount++\n      $query = \"$queryTarget.$($bl.zone)\"\n      $listed = $false\n      \n      try {\n        $result = Resolve-DnsName -Name $query -Type A -ErrorAction Stop 2>$null\n        if ($result) { $listed = $true; $targetResult.listedCount++ }\n      } catch { }\n      \n      $targetResult.listings += [pscustomobject]@{ blacklist = $bl.name; zone = $bl.zone; listed = $listed }\n    }\n    \n    # Output table\n    $rows = @()\n    foreach ($l in $targetResult.listings) {\n      $status = if ($l.listed) { 'LISTED' } else { 'Clean' }\n      $rows += ,@($l.blacklist, $status)\n    }\n    $caption = if ($targetResult.listedCount -eq 0) { 'Not listed on any blacklist' } else { \"LISTED on $($targetResult.listedCount) blacklist(s)!\" }\n    Write-XY @{ table = @{ title=\"Blacklist Check - $target\"; header=@('Blacklist','Status'); rows=$rows; caption=$caption } }\n    \n    $results.Add([pscustomobject]$targetResult)\n  }\n  \n  # Summary\n  if ($targets.Count -gt 1) {\n    $summaryRows = @()\n    foreach ($r in $results) {\n      $status = if ($r.listedCount -eq 0) { 'Clean' } else { \"LISTED ($($r.listedCount))\" }\n      $summaryRows += ,@($r.target, $r.type, $status)\n    }\n    Write-XY @{ table = @{ title='Blacklist Summary'; header=@('Target','Type','Status'); rows=$summaryRows; caption='' } }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  [pscustomobject]@{ tool='Blacklist Checker'; targetsChecked=$targets.Count; results=$results.ToArray() }\n}\n\n# ------------------------- SMTP Checker -------------------------\nfunction Invoke-SmtpChecker {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = Get-Param $Params 'smtpSource' 'field'\n  $serversInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'smtpDataPath' ''\n    $serversInput = Get-NestedValue $inputData $path\n    if ($null -eq $serversInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $serversInput = Get-Param $Params 'smtpServers' '' }\n  \n  $servers = @(Get-MultipleInputs $serversInput 10)\n  if ($servers.Count -eq 0) { throw 'No SMTP server(s) specified' }\n  \n  $port = [int](Get-Param $Params 'smtpPort' 25)\n  $timeout = [int](Get-Param $Params 'smtpTimeout' 10000)\n  $sendTest = [bool](Get-Param $Params 'smtpSendTest' $false)\n  $testFrom = Get-Param $Params 'smtpTestFrom' ''\n  $testTo = Get-Param $Params 'smtpTestTo' ''\n  $authUser = Get-Param $Params 'smtpUsername' ''\n  $authPass = Get-Param $Params 'smtpPassword' ''\n  \n  Write-XYProgress 0.2 \"Checking $($servers.Count) SMTP server(s)...\"\n  \n  $results = [System.Collections.Generic.List[object]]::new()\n  \n  foreach ($server in $servers) {\n    $serverHost = $server -replace ':.*$', ''\n    $serverPort = if ($server -match ':(\\d+)$') { [int]$Matches[1] } else { $port }\n    \n    Write-XYProgress 0.3 \"Checking $serverHost`:$serverPort...\"\n    \n    $serverResult = @{\n      server = $serverHost; port = $serverPort; success = $false\n      banner = ''; starttls = $false; authMethods = @(); tlsVersion = ''; openRelay = 'Not tested'\n      testMailSent = $false; error = ''\n    }\n    \n    try {\n      $client = [System.Net.Sockets.TcpClient]::new()\n      $client.ReceiveTimeout = $timeout\n      $client.SendTimeout = $timeout\n      $client.Connect($serverHost, $serverPort)\n      \n      $stream = $client.GetStream()\n      $reader = [System.IO.StreamReader]::new($stream)\n      $writer = [System.IO.StreamWriter]::new($stream)\n      $writer.AutoFlush = $true\n      \n      # Read banner\n      $banner = $reader.ReadLine()\n      $serverResult.banner = $banner\n      $serverResult.success = $true\n      \n      # Send EHLO\n      $writer.WriteLine(\"EHLO test.local\")\n      $ehloResponse = @()\n      do {\n        $line = $reader.ReadLine()\n        $ehloResponse += $line\n        \n        if ($line -match 'STARTTLS') { $serverResult.starttls = $true }\n        if ($line -match 'AUTH (.+)$') { $serverResult.authMethods = $Matches[1] -split '\\s+' }\n      } while ($line -match '^250-')\n      \n      # Try STARTTLS if available\n      if ($serverResult.starttls -and $serverPort -ne 465) {\n        $writer.WriteLine('STARTTLS')\n        $starttlsResp = $reader.ReadLine()\n        if ($starttlsResp -match '^220') {\n          $sslStream = [System.Net.Security.SslStream]::new($stream, $false)\n          $sslStream.AuthenticateAsClient($serverHost)\n          $serverResult.tlsVersion = $sslStream.SslProtocol.ToString()\n          $reader = [System.IO.StreamReader]::new($sslStream)\n          $writer = [System.IO.StreamWriter]::new($sslStream)\n          $writer.AutoFlush = $true\n          \n          # Re-EHLO after STARTTLS\n          $writer.WriteLine(\"EHLO test.local\")\n          do { $line = $reader.ReadLine() } while ($line -match '^250-')\n        }\n      }\n      \n      # Test for open relay (if not sending test mail)\n      if (-not $sendTest) {\n        $writer.WriteLine('MAIL FROM:<test@example.com>')\n        $mailResp = $reader.ReadLine()\n        if ($mailResp -match '^250') {\n          $writer.WriteLine('RCPT TO:<test@example.org>')\n          $rcptResp = $reader.ReadLine()\n          $serverResult.openRelay = if ($rcptResp -match '^250') { 'VULNERABLE!' } else { 'Protected' }\n        }\n        $writer.WriteLine('RSET')\n        $reader.ReadLine() | Out-Null\n      }\n      \n      # Send test mail if requested\n      if ($sendTest -and $testFrom -and $testTo) {\n        if ($authUser -and $authPass) {\n          # Authenticate first\n          $writer.WriteLine('AUTH LOGIN')\n          $reader.ReadLine() | Out-Null\n          $writer.WriteLine([Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($authUser)))\n          $reader.ReadLine() | Out-Null\n          $writer.WriteLine([Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($authPass)))\n          $authResp = $reader.ReadLine()\n          if ($authResp -notmatch '^235') { throw \"Authentication failed: $authResp\" }\n        }\n        \n        $writer.WriteLine(\"MAIL FROM:<$testFrom>\")\n        $mailResp = $reader.ReadLine()\n        if ($mailResp -match '^250') {\n          $writer.WriteLine(\"RCPT TO:<$testTo>\")\n          $rcptResp = $reader.ReadLine()\n          if ($rcptResp -match '^250') {\n            $writer.WriteLine('DATA')\n            $dataResp = $reader.ReadLine()\n            if ($dataResp -match '^354') {\n              $writer.WriteLine(\"From: $testFrom\")\n              $writer.WriteLine(\"To: $testTo\")\n              $writer.WriteLine(\"Subject: SMTP Test from xyOps\")\n              $writer.WriteLine(\"Date: $([DateTime]::UtcNow.ToString('r'))\")\n              $writer.WriteLine('')\n              $writer.WriteLine('This is a test email sent by xyOps SMTP Checker.')\n              $writer.WriteLine('.')\n              $finalResp = $reader.ReadLine()\n              $serverResult.testMailSent = $finalResp -match '^250'\n            }\n          }\n        }\n      }\n      \n      $writer.WriteLine('QUIT')\n      $client.Close()\n      \n    } catch {\n      $serverResult.error = $_.Exception.Message\n    }\n    \n    # Output table\n    $rows = @(\n      @('Server', \"$serverHost`:$serverPort\"),\n      @('Status', $(if ($serverResult.success) { 'Connected' } else { 'Failed' })),\n      @('Banner', $(if ($serverResult.banner) { $serverResult.banner } else { '-' })),\n      @('STARTTLS', $(if ($serverResult.starttls) { 'Supported' } else { 'Not available' })),\n      @('TLS Version', $(if ($serverResult.tlsVersion) { $serverResult.tlsVersion } else { '-' })),\n      @('Auth Methods', $(if ($serverResult.authMethods.Count -gt 0) { $serverResult.authMethods -join ', ' } else { 'None' })),\n      @('Open Relay', $serverResult.openRelay)\n    )\n    if ($sendTest) { $rows += ,@('Test Mail', $(if ($serverResult.testMailSent) { 'Sent successfully' } else { 'Not sent' })) }\n    if ($serverResult.error) { $rows += ,@('Error', $serverResult.error) }\n    \n    Write-XY @{ table = @{ title=\"SMTP Check - $serverHost\"; header=@('Property','Value'); rows=$rows; caption='' } }\n    \n    $results.Add([pscustomobject]$serverResult)\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  [pscustomobject]@{ tool='SMTP Checker'; serversChecked=$servers.Count; results=$results.ToArray() }\n}\n\n# ------------------------- Bandwidth/Speed Test -------------------------\nfunction Invoke-BandwidthTest {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $mode = Get-Param $Params 'bwMode' 'cloudflare'\n  $customUrl = Get-Param $Params 'bwCustomUrl' ''\n  $testSize = Get-Param $Params 'bwTestSize' 'medium'\n  \n  Write-XYProgress 0.2 'Starting bandwidth test...'\n  \n  $result = @{ tool = 'Bandwidth Test'; mode = $mode; downloadSpeed = $null; uploadSpeed = $null; latency = $null }\n  \n  try {\n    if ($mode -eq 'cloudflare') {\n      # Test latency first\n      Write-XYProgress 0.3 'Testing latency...'\n      $latencies = @()\n      for ($i = 0; $i -lt 3; $i++) {\n        $sw = [System.Diagnostics.Stopwatch]::StartNew()\n        Invoke-WebRequest -Uri 'https://cloudflare.com/cdn-cgi/trace' -UseBasicParsing -TimeoutSec 10 | Out-Null\n        $sw.Stop()\n        $latencies += $sw.ElapsedMilliseconds\n      }\n      $result.latency = [Math]::Round(($latencies | Measure-Object -Average).Average, 0)\n      \n      # Download test\n      Write-XYProgress 0.4 'Testing download speed...'\n      $sizes = @{ small = 1000000; medium = 10000000; large = 25000000 }\n      $testBytes = $sizes[$testSize]\n      $downloadUrl = \"https://speed.cloudflare.com/__down?bytes=$testBytes\"\n      \n      $sw = [System.Diagnostics.Stopwatch]::StartNew()\n      $response = Invoke-WebRequest -Uri $downloadUrl -UseBasicParsing -TimeoutSec 120\n      $sw.Stop()\n      \n      $downloadedBytes = $response.Content.Length\n      $downloadSeconds = $sw.Elapsed.TotalSeconds\n      $downloadMbps = [Math]::Round(($downloadedBytes * 8) / $downloadSeconds / 1000000, 2)\n      $result.downloadSpeed = $downloadMbps\n      $result.downloadBytes = $downloadedBytes\n      $result.downloadTime = [Math]::Round($downloadSeconds, 2)\n      \n      # Upload test (smaller payload)\n      Write-XYProgress 0.7 'Testing upload speed...'\n      $uploadData = [byte[]]::new(1000000)  # 1MB\n      [System.Random]::new().NextBytes($uploadData)\n      \n      $sw = [System.Diagnostics.Stopwatch]::StartNew()\n      try {\n        Invoke-WebRequest -Uri 'https://speed.cloudflare.com/__up' -Method POST -Body $uploadData -UseBasicParsing -TimeoutSec 60 | Out-Null\n        $sw.Stop()\n        $uploadSeconds = $sw.Elapsed.TotalSeconds\n        $uploadMbps = [Math]::Round(($uploadData.Length * 8) / $uploadSeconds / 1000000, 2)\n        $result.uploadSpeed = $uploadMbps\n        $result.uploadTime = [Math]::Round($uploadSeconds, 2)\n      } catch {\n        $result.uploadSpeed = 'N/A'\n        $result.uploadError = $_.Exception.Message\n      }\n    }\n    elseif ($mode -eq 'custom' -and $customUrl) {\n      Write-XYProgress 0.4 'Testing download from custom URL...'\n      \n      $sw = [System.Diagnostics.Stopwatch]::StartNew()\n      $response = Invoke-WebRequest -Uri $customUrl -UseBasicParsing -TimeoutSec 120\n      $sw.Stop()\n      \n      $downloadedBytes = $response.Content.Length\n      $downloadSeconds = $sw.Elapsed.TotalSeconds\n      $downloadMbps = [Math]::Round(($downloadedBytes * 8) / $downloadSeconds / 1000000, 2)\n      \n      $result.downloadSpeed = $downloadMbps\n      $result.downloadBytes = $downloadedBytes\n      $result.downloadTime = [Math]::Round($downloadSeconds, 2)\n      $result.customUrl = $customUrl\n    }\n    else {\n      throw 'Invalid mode or missing custom URL'\n    }\n    \n    # Output table\n    $rows = @(\n      @('Mode', $(if ($mode -eq 'cloudflare') { 'Cloudflare Speed Test' } else { \"Custom: $customUrl\" })),\n      @('Download Speed', \"$($result.downloadSpeed) Mbps\"),\n      @('Download Size', \"$([Math]::Round($result.downloadBytes / 1000000, 2)) MB\"),\n      @('Download Time', \"$($result.downloadTime) seconds\")\n    )\n    if ($result.uploadSpeed -and $result.uploadSpeed -ne 'N/A') {\n      $rows += ,@('Upload Speed', \"$($result.uploadSpeed) Mbps\")\n    }\n    if ($result.latency) {\n      $rows += ,@('Latency', \"$($result.latency) ms\")\n    }\n    \n    Write-XY @{ table = @{ title='Bandwidth Test Results'; header=@('Metric','Value'); rows=$rows; caption='' } }\n    \n  } catch {\n    $result.error = $_.Exception.Message\n    Write-XY @{ table = @{ title='Bandwidth Test'; header=@('Error'); rows=@(,@($_.Exception.Message)); caption='Test failed' } }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  [pscustomobject]$result\n}\n\n# ------------------------- TCP/UDP Listener -------------------------\nfunction Invoke-PortListener {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $protocol = Get-Param $Params 'listenerProtocol' 'TCP'\n  $port = [int](Get-Param $Params 'listenerPort' 8080)\n  $timeout = [int](Get-Param $Params 'listenerTimeout' 60)\n  $maxConnections = [int](Get-Param $Params 'listenerMaxConn' 10)\n  \n  if ($port -lt 1 -or $port -gt 65535) { throw \"Invalid port: $port\" }\n  $timeout = [Math]::Min(300, [Math]::Max(5, $timeout))\n  \n  Write-XYProgress 0.2 \"Starting $protocol listener on port $port for ${timeout}s...\"\n  \n  $connections = [System.Collections.Generic.List[object]]::new()\n  $startTime = [DateTime]::UtcNow\n  \n  try {\n    if ($protocol -eq 'TCP') {\n      $listener = [System.Net.Sockets.TcpListener]::new([System.Net.IPAddress]::Any, $port)\n      $listener.Start()\n      \n      Write-XY @{ table = @{ title='TCP Listener'; header=@('Status'); rows=@(,@(\"Listening on port $port...\")); caption=\"Waiting for connections (max ${timeout}s)\" } }\n      \n      $endTime = $startTime.AddSeconds($timeout)\n      \n      while ([DateTime]::UtcNow -lt $endTime -and $connections.Count -lt $maxConnections) {\n        if ($listener.Pending()) {\n          $client = $listener.AcceptTcpClient()\n          $remoteEP = $client.Client.RemoteEndPoint\n          $connTime = [DateTime]::UtcNow\n          \n          $dataReceived = ''\n          try {\n            $stream = $client.GetStream()\n            $stream.ReadTimeout = 2000\n            $buffer = [byte[]]::new(4096)\n            # Wait up to 500ms for data to arrive\n            $waitCount = 0\n            while (-not $stream.DataAvailable -and $waitCount -lt 50) {\n              Start-Sleep -Milliseconds 10\n              $waitCount++\n            }\n            if ($stream.DataAvailable) {\n              $bytesRead = $stream.Read($buffer, 0, $buffer.Length)\n              if ($bytesRead -gt 0) {\n                $dataReceived = [System.Text.Encoding]::UTF8.GetString($buffer, 0, $bytesRead)\n                if ($dataReceived.Length -gt 200) { $dataReceived = $dataReceived.Substring(0, 200) + '...' }\n              }\n            }\n          } catch { }\n          \n          $connObj = [pscustomobject]@{\n            timestamp = $connTime.ToString('HH:mm:ss')\n            sourceIP = $remoteEP.Address.ToString()\n            sourcePort = $remoteEP.Port\n            data = $dataReceived\n          }\n          $connections.Add($connObj)\n          \n          # Output immediately and flush\n          Write-XY @{ table = @{ title=\"TCP Connection #$($connections.Count)\"; header=@('Property','Value'); rows=@(@('Time', $connObj.timestamp), @('Source', \"$($connObj.sourceIP):$($connObj.sourcePort)\"), @('Data', $(if ($connObj.data) { $connObj.data } else { '(no data)' }))); caption='' } }\n          [Console]::Out.Flush()\n          \n          $client.Close()\n        }\n        Start-Sleep -Milliseconds 100\n        \n        $elapsed = ([DateTime]::UtcNow - $startTime).TotalSeconds\n        Write-XYProgress (0.2 + (0.7 * $elapsed / $timeout)) \"Listening... ($($connections.Count) connections)\"\n      }\n      \n      $listener.Stop()\n    }\n    else {\n      # UDP Listener\n      $udpClient = [System.Net.Sockets.UdpClient]::new($port)\n      $udpClient.Client.ReceiveTimeout = 1000\n      \n      Write-XY @{ table = @{ title='UDP Listener'; header=@('Status'); rows=@(,@(\"Listening on port $port...\")); caption=\"Waiting for datagrams (max ${timeout}s)\" } }\n      \n      $endTime = $startTime.AddSeconds($timeout)\n      \n      while ([DateTime]::UtcNow -lt $endTime -and $connections.Count -lt $maxConnections) {\n        try {\n          $remoteEP = [System.Net.IPEndPoint]::new([System.Net.IPAddress]::Any, 0)\n          $data = $udpClient.Receive([ref]$remoteEP)\n          $connTime = [DateTime]::UtcNow\n          \n          $dataStr = [System.Text.Encoding]::UTF8.GetString($data)\n          if ($dataStr.Length -gt 200) { $dataStr = $dataStr.Substring(0, 200) + '...' }\n          \n          $connObj = [pscustomobject]@{\n            timestamp = $connTime.ToString('HH:mm:ss')\n            sourceIP = $remoteEP.Address.ToString()\n            sourcePort = $remoteEP.Port\n            data = $dataStr\n            size = $data.Length\n          }\n          $connections.Add($connObj)\n          \n          # Output immediately and flush\n          Write-XY @{ table = @{ title=\"UDP Datagram #$($connections.Count)\"; header=@('Property','Value'); rows=@(@('Time', $connObj.timestamp), @('Source', \"$($connObj.sourceIP):$($connObj.sourcePort)\"), @('Size', \"$($connObj.size) bytes\"), @('Data', $(if ($connObj.data) { $connObj.data } else { '(no data)' }))); caption='' } }\n          [Console]::Out.Flush()\n        } catch [System.Net.Sockets.SocketException] {\n          # Timeout, continue\n        }\n        \n        $elapsed = ([DateTime]::UtcNow - $startTime).TotalSeconds\n        Write-XYProgress (0.2 + (0.7 * $elapsed / $timeout)) \"Listening... ($($connections.Count) datagrams)\"\n      }\n      \n      $udpClient.Close()\n    }\n    \n    # Output results\n    if ($connections.Count -gt 0) {\n      $rows = @()\n      foreach ($c in $connections) {\n        $dataPreview = if ($c.data) { $c.data.Substring(0, [Math]::Min(50, $c.data.Length)) } else { '-' }\n        $rows += ,@($c.timestamp, \"$($c.sourceIP):$($c.sourcePort)\", $dataPreview)\n      }\n      Write-XY @{ table = @{ title=\"$protocol Connections Received\"; header=@('Time','Source','Data Preview'); rows=$rows; caption=\"$($connections.Count) connection(s) received\" } }\n    } else {\n      Write-XY @{ table = @{ title=\"$protocol Listener\"; header=@('Result'); rows=@(,@('No connections received')); caption=\"Listened for $timeout seconds\" } }\n    }\n    \n  } catch {\n    throw \"Listener error: $($_.Exception.Message)\"\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  [pscustomobject]@{ tool='Port Listener'; protocol=$protocol; port=$port; duration=$timeout; connectionsReceived=$connections.Count; connections=$connections.ToArray() }\n}\n\n# ------------------------- WebSocket Tester -------------------------\nfunction Invoke-WebSocketTest {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $wsUrl = Get-Param $Params 'wsUrl' ''\n  if (-not $wsUrl) { throw 'No WebSocket URL specified' }\n  \n  $sendMessage = Get-Param $Params 'wsSendMessage' ''\n  $timeout = [int](Get-Param $Params 'wsTimeout' 10)\n  \n  Write-XYProgress 0.2 \"Connecting to $wsUrl...\"\n  \n  $result = @{ tool = 'WebSocket Tester'; url = $wsUrl; connected = $false; messagesSent = 0; messagesReceived = 0; messages = @() }\n  \n  try {\n    $ws = [System.Net.WebSockets.ClientWebSocket]::new()\n    $cts = [System.Threading.CancellationTokenSource]::new()\n    $cts.CancelAfter([TimeSpan]::FromSeconds($timeout))\n    \n    $connectTask = $ws.ConnectAsync([Uri]$wsUrl, $cts.Token)\n    $connectTask.Wait()\n    \n    $result.connected = $ws.State -eq 'Open'\n    \n    if ($result.connected) {\n      Write-XYProgress 0.4 'Connected! Sending message...'\n      \n      # Send message if provided\n      if ($sendMessage) {\n        $sendBuffer = [System.Text.Encoding]::UTF8.GetBytes($sendMessage)\n        $sendSegment = [System.ArraySegment[byte]]::new($sendBuffer)\n        $sendTask = $ws.SendAsync($sendSegment, [System.Net.WebSockets.WebSocketMessageType]::Text, $true, $cts.Token)\n        $sendTask.Wait()\n        $result.messagesSent++\n        $result.messages += [pscustomobject]@{ direction = 'Sent'; data = $sendMessage; timestamp = [DateTime]::UtcNow.ToString('HH:mm:ss.fff') }\n      }\n      \n      # Try to receive response\n      Write-XYProgress 0.6 'Waiting for response...'\n      $receiveBuffer = [byte[]]::new(8192)\n      $receiveSegment = [System.ArraySegment[byte]]::new($receiveBuffer)\n      \n      try {\n        $receiveCts = [System.Threading.CancellationTokenSource]::new()\n        $receiveCts.CancelAfter([TimeSpan]::FromSeconds(5))\n        $receiveTask = $ws.ReceiveAsync($receiveSegment, $receiveCts.Token)\n        $receiveTask.Wait()\n        \n        if ($receiveTask.Result.Count -gt 0) {\n          $receivedData = [System.Text.Encoding]::UTF8.GetString($receiveBuffer, 0, $receiveTask.Result.Count)\n          $result.messagesReceived++\n          $result.messages += [pscustomobject]@{ direction = 'Received'; data = $receivedData; timestamp = [DateTime]::UtcNow.ToString('HH:mm:ss.fff') }\n        }\n      } catch { }\n      \n      # Close connection\n      if ($ws.State -eq 'Open') {\n        $closeCts = [System.Threading.CancellationTokenSource]::new()\n        $closeCts.CancelAfter([TimeSpan]::FromSeconds(5))\n        $closeTask = $ws.CloseAsync([System.Net.WebSockets.WebSocketCloseStatus]::NormalClosure, 'Test complete', $closeCts.Token)\n        $closeTask.Wait()\n      }\n    }\n    \n    # Output table\n    $rows = @(\n      @('URL', $wsUrl),\n      @('Connected', $(if ($result.connected) { 'Yes' } else { 'No' })),\n      @('Messages Sent', $result.messagesSent),\n      @('Messages Received', $result.messagesReceived)\n    )\n    Write-XY @{ table = @{ title='WebSocket Test'; header=@('Property','Value'); rows=$rows; caption='' } }\n    \n    if ($result.messages.Count -gt 0) {\n      $msgRows = @()\n      foreach ($m in $result.messages) {\n        $preview = if ($m.data.Length -gt 100) { $m.data.Substring(0, 100) + '...' } else { $m.data }\n        $msgRows += ,@($m.timestamp, $m.direction, $preview)\n      }\n      Write-XY @{ table = @{ title='Messages'; header=@('Time','Direction','Data'); rows=$msgRows; caption='' } }\n    }\n    \n  } catch {\n    $result.error = $_.Exception.InnerException?.Message ?? $_.Exception.Message\n    Write-XY @{ table = @{ title='WebSocket Test'; header=@('Property','Value'); rows=@(@('URL', $wsUrl), @('Error', $result.error)); caption='Connection failed' } }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  [pscustomobject]$result\n}\n\n# ------------------------- API Health Monitor -------------------------\nfunction Invoke-ApiHealthMonitor {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = Get-Param $Params 'apiSource' 'field'\n  $endpointsInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'apiDataPath' ''\n    $endpointsInput = Get-NestedValue $inputData $path\n    if ($null -eq $endpointsInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $endpointsInput = Get-Param $Params 'apiEndpoints' '' }\n  \n  $endpoints = @(Get-MultipleInputs $endpointsInput 20)\n  if ($endpoints.Count -eq 0) { throw 'No endpoint(s) specified' }\n  \n  $expectedStatus = Get-Param $Params 'apiExpectedStatus' '200'\n  $timeout = [int](Get-Param $Params 'apiTimeout' 10)\n  $validateJson = Get-Param $Params 'apiValidateJson' ''\n  \n  Write-XYProgress 0.2 \"Checking $($endpoints.Count) endpoint(s)...\"\n  \n  $results = [System.Collections.Generic.List[object]]::new()\n  $healthyCount = 0\n  \n  $epIndex = 0\n  foreach ($endpoint in $endpoints) {\n    $epIndex++\n    if ($endpoint -notmatch '^https?://') { $endpoint = \"https://$endpoint\" }\n    \n    Write-XYProgress (0.2 + (0.7 * $epIndex / $endpoints.Count)) \"Checking $endpoint...\"\n    \n    $epResult = @{ endpoint = $endpoint; healthy = $false; statusCode = 0; responseTime = 0; error = ''; validationError = '' }\n    \n    try {\n      $sw = [System.Diagnostics.Stopwatch]::StartNew()\n      $response = Invoke-WebRequest -Uri $endpoint -UseBasicParsing -TimeoutSec $timeout -ErrorAction Stop\n      $sw.Stop()\n      \n      $epResult.statusCode = $response.StatusCode\n      $epResult.responseTime = $sw.ElapsedMilliseconds\n      \n      # Check expected status\n      $expectedCodes = @($expectedStatus -split '[,;]' | ForEach-Object { [int]$_.Trim() })\n      $statusMatch = $expectedCodes -contains $response.StatusCode\n      \n      # Validate JSON if specified\n      $jsonValid = $true\n      if ($validateJson -and $statusMatch) {\n        try {\n          $json = $response.Content | ConvertFrom-Json\n          # Simple JSONPath-like validation: field=value or just field (exists check)\n          foreach ($check in ($validateJson -split ';')) {\n            $check = $check.Trim()\n            if ($check -match '^([^=]+)=(.+)$') {\n              $field = $Matches[1].Trim()\n              $expected = $Matches[2].Trim()\n              $actual = $json.PSObject.Properties[$field]?.Value\n              if ([string]$actual -ne $expected) { $jsonValid = $false; $epResult.validationError = \"$field expected '$expected', got '$actual'\" }\n            } elseif ($check) {\n              if (-not $json.PSObject.Properties[$check]) { $jsonValid = $false; $epResult.validationError = \"Field '$check' not found\" }\n            }\n          }\n        } catch {\n          $jsonValid = $false\n          $epResult.validationError = 'Invalid JSON response'\n        }\n      }\n      \n      $epResult.healthy = $statusMatch -and $jsonValid\n      if ($epResult.healthy) { $healthyCount++ }\n      \n    } catch {\n      $epResult.error = $_.Exception.Message\n      if ($_.Exception.Response) {\n        $epResult.statusCode = [int]$_.Exception.Response.StatusCode\n      }\n    }\n    \n    $results.Add([pscustomobject]$epResult)\n  }\n  \n  # Output table\n  $rows = @()\n  foreach ($r in $results) {\n    $status = if ($r.healthy) { 'Healthy' } elseif ($r.error) { 'Error' } else { 'Unhealthy' }\n    $detail = if ($r.error) { $r.error.Substring(0, [Math]::Min(40, $r.error.Length)) } elseif ($r.validationError) { $r.validationError } else { \"$($r.statusCode) - $($r.responseTime)ms\" }\n    $rows += ,@($r.endpoint, $status, $detail)\n  }\n  Write-XY @{ table = @{ title='API Health Monitor'; header=@('Endpoint','Status','Details'); rows=$rows; caption=\"$healthyCount/$($endpoints.Count) endpoints healthy\" } }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  [pscustomobject]@{ tool='API Health Monitor'; endpointsChecked=$endpoints.Count; healthy=$healthyCount; unhealthy=($endpoints.Count - $healthyCount); results=$results.ToArray() }\n}\n\n# ------------------------- SNMP Query -------------------------\nfunction Invoke-SnmpQuery {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = Get-Param $Params 'snmpSource' 'field'\n  $hostsInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'snmpDataPath' ''\n    $hostsInput = Get-NestedValue $inputData $path\n    if ($null -eq $hostsInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $hostsInput = Get-Param $Params 'snmpHosts' '' }\n  \n  $hosts = @(Get-MultipleInputs $hostsInput 10)\n  if ($hosts.Count -eq 0) { throw 'No host(s) specified' }\n  \n  $version = Get-Param $Params 'snmpVersion' 'v2c'\n  $community = Get-Param $Params 'snmpCommunity' 'public'\n  $port = [int](Get-Param $Params 'snmpPort' 161)\n  $timeout = [int](Get-Param $Params 'snmpTimeout' 5000)\n  $customOids = Get-Param $Params 'snmpCustomOids' ''\n  \n  # SNMPv3 params\n  $v3User = Get-Param $Params 'snmpV3User' ''\n  $v3AuthProto = Get-Param $Params 'snmpV3AuthProto' 'SHA'\n  $v3AuthPass = Get-Param $Params 'snmpV3AuthPass' ''\n  $v3PrivProto = Get-Param $Params 'snmpV3PrivProto' 'AES'\n  $v3PrivPass = Get-Param $Params 'snmpV3PrivPass' ''\n  \n  # Standard OIDs\n  $standardOids = @{\n    'sysDescr' = '1.3.6.1.2.1.1.1.0'\n    'sysObjectID' = '1.3.6.1.2.1.1.2.0'\n    'sysUpTime' = '1.3.6.1.2.1.1.3.0'\n    'sysContact' = '1.3.6.1.2.1.1.4.0'\n    'sysName' = '1.3.6.1.2.1.1.5.0'\n    'sysLocation' = '1.3.6.1.2.1.1.6.0'\n  }\n  \n  # Add custom OIDs\n  if ($customOids) {\n    foreach ($oid in ($customOids -split '[,;\\n]+')) {\n      $oid = $oid.Trim()\n      if ($oid -match '^([^=]+)=(.+)$') {\n        $standardOids[$Matches[1].Trim()] = $Matches[2].Trim()\n      } elseif ($oid -match '^[0-9.]+$') {\n        $standardOids[\"Custom_$oid\"] = $oid\n      }\n    }\n  }\n  \n  Write-XYProgress 0.2 \"Querying $($hosts.Count) host(s) via SNMP $version...\"\n  \n  $results = [System.Collections.Generic.List[object]]::new()\n  \n  # Note: Full SNMP implementation requires external library\n  # This is a simplified UDP-based SNMPv1/v2c GET implementation\n  \n  foreach ($hostEntry in $hosts) {\n    $hostAddr = $hostEntry -replace ':.*$', ''\n    $hostPort = if ($hostEntry -match ':(\\d+)$') { [int]$Matches[1] } else { $port }\n    \n    Write-XYProgress 0.4 \"Querying $hostAddr...\"\n    \n    $hostResult = @{ host = $hostAddr; port = $hostPort; version = $version; success = $false; values = @{}; error = '' }\n    \n    try {\n      $udpClient = [System.Net.Sockets.UdpClient]::new()\n      $udpClient.Client.ReceiveTimeout = $timeout\n      $udpClient.Connect($hostAddr, $hostPort)\n      \n      foreach ($oidName in $standardOids.Keys) {\n        $oid = $standardOids[$oidName]\n        \n        # Build simple SNMP GET request (v1/v2c)\n        $oidParts = $oid -split '\\.' | ForEach-Object { [int]$_ }\n        $oidBytes = @()\n        \n        # Encode OID\n        $oidBytes += (40 * $oidParts[0] + $oidParts[1])\n        for ($i = 2; $i -lt $oidParts.Count; $i++) {\n          $val = $oidParts[$i]\n          if ($val -lt 128) {\n            $oidBytes += $val\n          } else {\n            $encoded = @()\n            while ($val -gt 0) {\n              $encoded = ,($val -band 0x7F) + $encoded\n              $val = $val -shr 7\n            }\n            for ($j = 0; $j -lt $encoded.Count - 1; $j++) { $encoded[$j] = $encoded[$j] -bor 0x80 }\n            $oidBytes += $encoded\n          }\n        }\n        \n        $communityBytes = [System.Text.Encoding]::ASCII.GetBytes($community)\n        \n        # Build PDU\n        $varbind = @(0x30, ($oidBytes.Count + 4), 0x06, $oidBytes.Count) + $oidBytes + @(0x05, 0x00)  # OID + NULL\n        $varbindList = @(0x30, $varbind.Count) + $varbind\n        \n        $pduType = if ($version -eq 'v1') { 0xA0 } else { 0xA0 }  # GetRequest\n        $requestId = @(0x02, 0x01, 0x01)  # Integer: 1\n        $errorStatus = @(0x02, 0x01, 0x00)\n        $errorIndex = @(0x02, 0x01, 0x00)\n        $pduContent = $requestId + $errorStatus + $errorIndex + $varbindList\n        $pdu = @($pduType, $pduContent.Count) + $pduContent\n        \n        $snmpVersion = if ($version -eq 'v1') { @(0x02, 0x01, 0x00) } else { @(0x02, 0x01, 0x01) }\n        $communityField = @(0x04, $communityBytes.Count) + $communityBytes\n        $message = $snmpVersion + $communityField + $pdu\n        $packet = @(0x30, $message.Count) + $message\n        \n        $udpClient.Send([byte[]]$packet, $packet.Count) | Out-Null\n        \n        try {\n          $remoteEP = [System.Net.IPEndPoint]::new([System.Net.IPAddress]::Any, 0)\n          $response = $udpClient.Receive([ref]$remoteEP)\n          \n          # Simple response parsing - look for string/integer values\n          $responseStr = [System.Text.Encoding]::ASCII.GetString($response)\n          \n          # Extract value (simplified - looks for printable ASCII after the OID)\n          $valueStart = $response.Length - 1\n          while ($valueStart -gt 0 -and $response[$valueStart] -ge 32 -and $response[$valueStart] -le 126) { $valueStart-- }\n          $valueStart++\n          \n          if ($valueStart -lt $response.Length) {\n            $value = [System.Text.Encoding]::ASCII.GetString($response, $valueStart, $response.Length - $valueStart).Trim()\n            if ($value) { $hostResult.values[$oidName] = $value }\n          }\n          \n          $hostResult.success = $true\n        } catch { }\n      }\n      \n      $udpClient.Close()\n      \n    } catch {\n      $hostResult.error = $_.Exception.Message\n    }\n    \n    # Output table\n    if ($hostResult.success -and $hostResult.values.Count -gt 0) {\n      $rows = @()\n      foreach ($key in $hostResult.values.Keys) {\n        $rows += ,@($key, $hostResult.values[$key])\n      }\n      Write-XY @{ table = @{ title=\"SNMP - $hostAddr\"; header=@('OID Name','Value'); rows=$rows; caption=\"$($hostResult.values.Count) values retrieved\" } }\n    } else {\n      $errMsg = if ($hostResult.error) { $hostResult.error } else { 'No response or empty values' }\n      Write-XY @{ table = @{ title=\"SNMP - $hostAddr\"; header=@('Status'); rows=@(,@($errMsg)); caption='Query failed' } }\n    }\n    \n    $results.Add([pscustomobject]$hostResult)\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  [pscustomobject]@{ tool='SNMP Query'; hostsQueried=$hosts.Count; version=$version; results=$results.ToArray() }\n}\n\n# ------------------------- LDAP/AD Test -------------------------\nfunction Invoke-LdapTest {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = Get-Param $Params 'ldapSource' 'field'\n  $serversInput = $null\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = Get-Param $Params 'ldapDataPath' ''\n    $serversInput = Get-NestedValue $inputData $path\n    if ($null -eq $serversInput) { throw \"Data path '$path' not found in input data\" }\n  } else { $serversInput = Get-Param $Params 'ldapServers' '' }\n  \n  $servers = @(Get-MultipleInputs $serversInput 10)\n  if ($servers.Count -eq 0) { throw 'No LDAP server(s) specified' }\n  \n  $port = [int](Get-Param $Params 'ldapPort' 389)\n  $useSsl = [bool](Get-Param $Params 'ldapUseSsl' $false)\n  $baseDn = Get-Param $Params 'ldapBaseDn' ''\n  $bindDn = Get-Param $Params 'ldapBindDn' ''\n  $bindPassword = Get-Param $Params 'ldapBindPassword' ''\n  $searchFilter = Get-Param $Params 'ldapSearchFilter' '(objectClass=*)'\n  $searchScope = Get-Param $Params 'ldapSearchScope' 'base'\n  \n  if ($useSsl -and $port -eq 389) { $port = 636 }\n  \n  Write-XYProgress 0.2 \"Testing $($servers.Count) LDAP server(s)...\"\n  \n  $results = [System.Collections.Generic.List[object]]::new()\n  \n  foreach ($server in $servers) {\n    $serverHost = $server -replace ':.*$', ''\n    $serverPort = if ($server -match ':(\\d+)$') { [int]$Matches[1] } else { $port }\n    \n    Write-XYProgress 0.4 \"Testing $serverHost`:$serverPort...\"\n    \n    $serverResult = @{\n      server = $serverHost; port = $serverPort; ssl = $useSsl\n      connected = $false; bound = $false; searchSuccess = $false\n      bindType = 'Anonymous'; searchResults = 0; error = ''\n    }\n    \n    try {\n      # Use System.DirectoryServices.Protocols for LDAP\n      $ldapId = [System.DirectoryServices.Protocols.LdapDirectoryIdentifier]::new($serverHost, $serverPort)\n      $ldapConn = [System.DirectoryServices.Protocols.LdapConnection]::new($ldapId)\n      \n      $ldapConn.SessionOptions.ProtocolVersion = 3\n      $ldapConn.SessionOptions.SecureSocketLayer = $useSsl\n      $ldapConn.Timeout = [TimeSpan]::FromSeconds(10)\n      \n      # Try to bind\n      if ($bindDn -and $bindPassword) {\n        $cred = [System.Net.NetworkCredential]::new($bindDn, $bindPassword)\n        $ldapConn.Credential = $cred\n        $ldapConn.AuthType = [System.DirectoryServices.Protocols.AuthType]::Basic\n        $serverResult.bindType = 'Authenticated'\n      } else {\n        $ldapConn.AuthType = [System.DirectoryServices.Protocols.AuthType]::Anonymous\n      }\n      \n      $ldapConn.Bind()\n      $serverResult.connected = $true\n      $serverResult.bound = $true\n      \n      # Try search if baseDn provided\n      if ($baseDn) {\n        $scope = switch ($searchScope) {\n          'base' { [System.DirectoryServices.Protocols.SearchScope]::Base }\n          'one' { [System.DirectoryServices.Protocols.SearchScope]::OneLevel }\n          'sub' { [System.DirectoryServices.Protocols.SearchScope]::Subtree }\n          default { [System.DirectoryServices.Protocols.SearchScope]::Base }\n        }\n        \n        $searchReq = [System.DirectoryServices.Protocols.SearchRequest]::new($baseDn, $searchFilter, $scope, $null)\n        $searchReq.SizeLimit = 10\n        \n        $searchResp = $ldapConn.SendRequest($searchReq)\n        $serverResult.searchSuccess = $true\n        $serverResult.searchResults = $searchResp.Entries.Count\n      }\n      \n      $ldapConn.Dispose()\n      \n    } catch {\n      $serverResult.error = $_.Exception.InnerException?.Message ?? $_.Exception.Message\n    }\n    \n    # Output table\n    $rows = @(\n      @('Server', \"$serverHost`:$serverPort\"),\n      @('SSL/TLS', $(if ($useSsl) { 'Yes' } else { 'No' })),\n      @('Connected', $(if ($serverResult.connected) { 'Yes' } else { 'No' })),\n      @('Bind Type', $serverResult.bindType),\n      @('Bind Success', $(if ($serverResult.bound) { 'Yes' } else { 'No' }))\n    )\n    if ($baseDn) {\n      $rows += ,@('Search Base', $baseDn)\n      $rows += ,@('Search Success', $(if ($serverResult.searchSuccess) { 'Yes' } else { 'No' }))\n      $rows += ,@('Results Found', $serverResult.searchResults)\n    }\n    if ($serverResult.error) { $rows += ,@('Error', $serverResult.error) }\n    \n    $caption = if ($serverResult.bound) { 'Connection successful' } else { 'Connection failed' }\n    Write-XY @{ table = @{ title=\"LDAP Test - $serverHost\"; header=@('Property','Value'); rows=$rows; caption=$caption } }\n    \n    $results.Add([pscustomobject]$serverResult)\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  [pscustomobject]@{ tool='LDAP Test'; serversTested=$servers.Count; results=$results.ToArray() }\n}\n\n# ------------------------- Main -------------------------\ntry {\n  $job = Read-JobFromStdin\n  $params = $job.params\n  $tool = if ($params.PSObject.Properties.Name -contains 'tool') { $params.tool } else { 'pingTest' }\n  $cwd = if ($job.PSObject.Properties.Name -contains 'cwd') { [string]$job.cwd } else { (Get-Location).Path }\n  $jobInput = if ($job.PSObject.Properties.Name -contains 'input') { $job.input } else { @{} }\n\n  $result = $null\n  switch ($tool) {\n    'ipAddressTools'   { $result = Invoke-IPAddressTools -Params $params -JobInput $jobInput }\n    'jwtDecoder'       { $result = Invoke-JWTDecoder -Params $params -JobInput $jobInput }\n    'pingTest'         { $result = Invoke-PingTest -Params $params -JobInput $jobInput }\n    'dnsLookup'        { $result = Invoke-DnsLookup -Params $params -JobInput $jobInput }\n    'traceroute'       { $result = Invoke-Traceroute -Params $params -JobInput $jobInput }\n    'portScanner'      { $result = Invoke-PortScanner -Params $params -JobInput $jobInput }\n    'httpChecker'      { $result = Invoke-HttpChecker -Params $params -JobInput $jobInput }\n    'sslChecker'       { $result = Invoke-SslChecker -Params $params -JobInput $jobInput }\n    'whoisLookup'      { $result = Invoke-WhoisLookup -Params $params -JobInput $jobInput }\n    'ntpCheck'         { $result = Invoke-NtpCheck -Params $params -JobInput $jobInput }\n    'networkScanner'   { $result = Invoke-NetworkScanner -Params $params -JobInput $jobInput }\n    'wakeOnLan'        { $result = Invoke-WakeOnLan -Params $params -JobInput $jobInput }\n    'subnetCalculator' { $result = Invoke-SubnetCalculator -Params $params -JobInput $jobInput }\n    'ipGeolocation'    { $result = Invoke-IPGeolocation -Params $params -JobInput $jobInput }\n    'emailAuthChecker' { $result = Invoke-EmailAuthChecker -Params $params -JobInput $jobInput }\n    'blacklistChecker' { $result = Invoke-BlacklistChecker -Params $params -JobInput $jobInput }\n    'smtpChecker'      { $result = Invoke-SmtpChecker -Params $params -JobInput $jobInput }\n    'bandwidthTest'    { $result = Invoke-BandwidthTest -Params $params -JobInput $jobInput }\n    'portListener'     { $result = Invoke-PortListener -Params $params -JobInput $jobInput }\n    'websocketTester'  { $result = Invoke-WebSocketTest -Params $params -JobInput $jobInput }\n    'apiHealthMonitor' { $result = Invoke-ApiHealthMonitor -Params $params -JobInput $jobInput }\n    'snmpQuery'        { $result = Invoke-SnmpQuery -Params $params -JobInput $jobInput }\n    'ldapTest'         { $result = Invoke-LdapTest -Params $params -JobInput $jobInput }\n    default            { throw \"Unknown tool: $tool\" }\n  }\n\n  Write-XYSuccess -Data $result -Description (\"{0} completed successfully\" -f $result.tool)\n  [Console]::Out.Flush()\n  exit 0\n}\ncatch {\n  Write-XYError -Code 1 -Description ($_.Exception.Message)\n  [Console]::Out.Flush()\n  exit 1\n}",
				"groups": [],
				"format": "",
				"params": [
					{
						"id": "tool",
						"title": "Tool",
						"type": "toolset",
						"caption": "Select a network tool.",
						"locked": false,
						"data": {
							"tools": [
								{
									"id": "ipAddressTools",
									"title": "IP Address Tools",
									"description": "Validate, convert, and analyze IP addresses.",
									"fields": [
										{
											"id": "ipMode",
											"title": "Mode",
											"type": "select",
											"value": "Validate & Analyze [validate], IP to Decimal [toDecimal], Decimal to IP [fromDecimal], IP to Binary [toBinary], Subnet Calculator [subnet]",
											"caption": "Select the operation to perform."
										},
										{
											"id": "ipSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the IP."
										},
										{
											"id": "ipInput",
											"title": "IP Address / Value",
											"type": "text",
											"value": "",
											"caption": "IP address or decimal value. For subnet mode, use CIDR (e.g., 192.168.1.0/24)."
										},
										{
											"id": "ipDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to the data field. (Used when Data Source is 'input data')"
										}
									]
								},
								{
									"id": "jwtDecoder",
									"title": "JWT Decoder",
									"description": "Decode and inspect JWT tokens (header, payload, expiration).",
									"fields": [
										{
											"id": "jwtSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the JWT."
										},
										{
											"id": "jwtInput",
											"title": "JWT Token",
											"type": "textarea",
											"value": "",
											"caption": "JWT token to decode."
										},
										{
											"id": "jwtDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to the data field. (Used when Data Source is 'input data')"
										}
									]
								},
								{
									"id": "pingTest",
									"title": "Ping Test",
									"description": "Ping a host and measure latency with statistics.",
									"fields": [
										{
											"id": "pingSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the host."
										},
										{
											"id": "pingHosts",
											"title": "Host(s)",
											"type": "textarea",
											"value": "",
											"caption": "Hostname(s) or IP address(es) to ping. Separate multiple with commas or newlines (max 20)."
										},
										{
											"id": "pingDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										},
										{
											"id": "pingCount",
											"title": "Ping Count",
											"type": "text",
											"value": 4,
											"variant": "number",
											"caption": "Number of pings to send (1-10)."
										},
										{
											"id": "pingTimeout",
											"title": "Timeout (ms)",
											"type": "text",
											"value": 1000,
											"variant": "number",
											"caption": "Timeout per ping in milliseconds (100-30000)."
										}
									]
								},
								{
									"id": "dnsLookup",
									"title": "DNS Lookup",
									"description": "Resolve DNS records including A, AAAA, MX, TXT, CNAME, NS, SOA, and PTR (reverse).",
									"fields": [
										{
											"id": "dnsSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the query."
										},
										{
											"id": "dnsQueries",
											"title": "Domain(s) / IP(s)",
											"type": "textarea",
											"value": "",
											"caption": "Domain name(s) or IP address(es). Separate multiple with commas or newlines (max 20)."
										},
										{
											"id": "dnsDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										},
										{
											"id": "dnsRecordType",
											"title": "Record Type",
											"type": "select",
											"value": "A Record (IPv4) [A], AAAA Record (IPv6) [AAAA], MX Record (Mail) [MX], TXT Record [TXT], CNAME Record [CNAME], NS Record (Name Server) [NS], SOA Record [SOA], PTR Record (Reverse DNS) [PTR]",
											"caption": "Type of DNS record to query."
										},
										{
											"id": "dnsServer",
											"title": "DNS Server (optional)",
											"type": "text",
											"value": "",
											"caption": "Custom DNS server (e.g., 8.8.8.8, 1.1.1.1). Leave empty for system DNS."
										}
									]
								},
								{
									"id": "traceroute",
									"title": "Traceroute",
									"description": "Trace the network path to a host, showing each hop.",
									"fields": [
										{
											"id": "traceSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the host."
										},
										{
											"id": "traceHosts",
											"title": "Host(s)",
											"type": "textarea",
											"value": "",
											"caption": "Hostname(s) or IP address(es) to trace. Separate multiple with commas or newlines (max 20)."
										},
										{
											"id": "traceDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										},
										{
											"id": "traceMaxHops",
											"title": "Max Hops",
											"type": "text",
											"value": 30,
											"variant": "number",
											"caption": "Maximum number of hops (1-64)."
										},
										{
											"id": "traceTimeout",
											"title": "Timeout (ms)",
											"type": "text",
											"value": 3000,
											"variant": "number",
											"caption": "Timeout per hop in milliseconds."
										},
										{
											"id": "traceResolveNames",
											"title": "Resolve Hostnames",
											"type": "checkbox",
											"value": true,
											"caption": "Resolve IP addresses to hostnames."
										}
									]
								},
								{
									"id": "portScanner",
									"title": "Port Scanner",
									"description": "Check if specific ports are open on a host.",
									"fields": [
										{
											"id": "portSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the host."
										},
										{
											"id": "portHosts",
											"title": "Host(s)",
											"type": "textarea",
											"value": "",
											"caption": "Hostname(s) or IP address(es) to scan. Separate multiple with commas or newlines (max 20)."
										},
										{
											"id": "portDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										},
										{
											"id": "portPorts",
											"title": "Ports",
											"type": "text",
											"value": "80,443",
											"caption": "Comma-separated ports or ranges (e.g., 80,443,8080-8090). Max 100 ports."
										},
										{
											"id": "portTimeout",
											"title": "Timeout (ms)",
											"type": "text",
											"value": 1000,
											"variant": "number",
											"caption": "Connection timeout per port in milliseconds."
										}
									]
								},
								{
									"id": "httpChecker",
									"title": "HTTP Status Checker",
									"description": "Check HTTP status, response time, and headers for a URL.",
									"fields": [
										{
											"id": "httpSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the URL."
										},
										{
											"id": "httpUrls",
											"title": "URL(s)",
											"type": "textarea",
											"value": "",
											"caption": "URL(s) to check (https:// added if not specified). Separate multiple with commas or newlines (max 20)."
										},
										{
											"id": "httpDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										},
										{
											"id": "httpMethod",
											"title": "HTTP Method",
											"type": "select",
											"value": "GET [GET], HEAD [HEAD], POST [POST]",
											"caption": "HTTP method to use."
										},
										{
											"id": "httpTimeout",
											"title": "Timeout (seconds)",
											"type": "text",
											"value": 10,
											"variant": "number",
											"caption": "Request timeout in seconds (1-60)."
										},
										{
											"id": "httpFollowRedirects",
											"title": "Follow Redirects",
											"type": "checkbox",
											"value": true,
											"caption": "Automatically follow HTTP redirects."
										}
									]
								},
								{
									"id": "sslChecker",
									"title": "SSL Certificate Checker",
									"description": "Check SSL/TLS certificate details, expiry, and validity.",
									"fields": [
										{
											"id": "sslSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the host."
										},
										{
											"id": "sslHosts",
											"title": "Host(s)",
											"type": "textarea",
											"value": "",
											"caption": "Hostname(s) or URL(s). Separate multiple with commas or newlines (max 20). Port 443 default."
										},
										{
											"id": "sslDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										}
									]
								},
								{
									"id": "whoisLookup",
									"title": "WHOIS Lookup",
									"description": "Look up domain registration information via WHOIS.",
									"fields": [
										{
											"id": "whoisSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the domain."
										},
										{
											"id": "whoisDomains",
											"title": "Domain(s)",
											"type": "textarea",
											"value": "",
											"caption": "Domain name(s) to look up. Separate multiple with commas or newlines (max 20)."
										},
										{
											"id": "whoisDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										}
									]
								},
								{
									"id": "ntpCheck",
									"title": "NTP Server Check",
									"description": "Check NTP server(s) for time sync, stratum, offset, and reachability.",
									"fields": [
										{
											"id": "ntpSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the NTP server(s)."
										},
										{
											"id": "ntpServers",
											"title": "NTP Server(s)",
											"type": "textarea",
											"value": "pool.ntp.org",
											"caption": "NTP server hostname(s) or IP(s). Separate multiple servers with commas or newlines (max 10)."
										},
										{
											"id": "ntpDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										},
										{
											"id": "ntpTimeout",
											"title": "Timeout (ms)",
											"type": "text",
											"value": 3000,
											"variant": "number",
											"caption": "Timeout per server in milliseconds (500-10000)."
										}
									]
								},
								{
									"id": "networkScanner",
									"title": "Network Scanner",
									"description": "Scan network(s) for active hosts, resolve hostnames, and get MAC addresses.",
									"fields": [
										{
											"id": "netScanSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the network(s)."
										},
										{
											"id": "netScanNetworks",
											"title": "Network(s) CIDR",
											"type": "textarea",
											"value": "",
											"caption": "Network(s) in CIDR notation (e.g., 192.168.1.0/24). Max /22 (1024 hosts). Separate multiple with commas or newlines."
										},
										{
											"id": "netScanDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										},
										{
											"id": "netScanTimeout",
											"title": "Timeout (ms)",
											"type": "text",
											"value": 500,
											"variant": "number",
											"caption": "Timeout per host in milliseconds (100-5000). Lower = faster but may miss slow hosts."
										}
									]
								},
								{
									"id": "wakeOnLan",
									"title": "Wake-on-LAN",
									"description": "Send Wake-on-LAN magic packets to wake up devices on the network.",
									"fields": [
										{
											"id": "wolSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the MAC address(es)."
										},
										{
											"id": "wolDevices",
											"title": "MAC Address(es)",
											"type": "textarea",
											"value": "",
											"caption": "MAC address(es) in format AA:BB:CC:DD:EE:FF or AA-BB-CC-DD-EE-FF. Separate multiple with commas or newlines (max 20)."
										},
										{
											"id": "wolDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										},
										{
											"id": "wolBroadcast",
											"title": "Broadcast Address",
											"type": "text",
											"value": "255.255.255.255",
											"caption": "Broadcast IP address (default: 255.255.255.255). Use subnet broadcast for specific networks."
										},
										{
											"id": "wolPort",
											"title": "Port",
											"type": "text",
											"value": 9,
											"variant": "number",
											"caption": "UDP port to send magic packet (usually 7 or 9)."
										}
									]
								},
								{
									"id": "subnetCalculator",
									"title": "Subnet Calculator",
									"description": "Advanced subnet calculator with VLSM planning and supernetting.",
									"fields": [
										{
											"id": "subnetMode",
											"title": "Mode",
											"type": "select",
											"value": "Calculate subnet details [calculate], VLSM Planning [vlsm], Supernet/Aggregate [supernet]",
											"caption": "Select the calculation mode."
										},
										{
											"id": "subnetCidr",
											"title": "Network CIDR",
											"type": "text",
											"value": "",
											"caption": "Network in CIDR notation (e.g., 192.168.1.0/24)."
										},
										{
											"id": "subnetVlsm",
											"title": "VLSM Host Requirements",
											"type": "textarea",
											"value": "",
											"caption": "For VLSM mode: comma-separated host counts per subnet (e.g., 50,30,20,10)."
										},
										{
											"id": "subnetSupernets",
											"title": "Networks to Aggregate",
											"type": "textarea",
											"value": "",
											"caption": "For supernet mode: networks to aggregate, one per line (e.g., 192.168.0.0/24, 192.168.1.0/24)."
										}
									]
								},
								{
									"id": "ipGeolocation",
									"title": "IP Geolocation",
									"description": "Look up geographic location, ISP, and organization for IP addresses.",
									"fields": [
										{
											"id": "geoSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the IP address(es)."
										},
										{
											"id": "geoIPs",
											"title": "IP Address(es)",
											"type": "textarea",
											"value": "",
											"caption": "IP address(es) or domains to look up. Separate multiple with commas or newlines (max 20)."
										},
										{
											"id": "geoDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										}
									]
								},
								{
									"id": "emailAuthChecker",
									"title": "Email Auth Checker (SPF/DKIM/DMARC)",
									"description": "Check and score SPF, DKIM, and DMARC records for email security.",
									"fields": [
										{
											"id": "emailAuthSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the domain(s)."
										},
										{
											"id": "emailAuthDomains",
											"title": "Domain(s)",
											"type": "textarea",
											"value": "",
											"caption": "Domain(s) to check. Separate multiple with commas or newlines (max 10)."
										},
										{
											"id": "emailAuthDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										},
										{
											"id": "emailAuthDkimSelector",
											"title": "DKIM Selector(s)",
											"type": "text",
											"value": "default,google,selector1,selector2,k1,s1",
											"caption": "DKIM selectors to check (comma-separated). Common: default, google, selector1, selector2, k1, s1."
										},
										{
											"id": "emailAuthDnsMode",
											"title": "DNS Server",
											"type": "select",
											"value": "Use internal DNS [internal], Use external DNS [external]",
											"caption": "Use internal DNS or external DNS for lookups. External DNS recommended for split-DNS environments."
										},
										{
											"id": "emailAuthExternalDns",
											"title": "External DNS Server",
											"type": "text",
											"value": "1.1.1.1",
											"caption": "External DNS server IP (used when DNS Server is set to external). Default: 1.1.1.1 (Cloudflare)."
										}
									]
								},
								{
									"id": "blacklistChecker",
									"title": "Blacklist Checker",
									"description": "Check if IP addresses or domains are listed on spam/security blacklists.",
									"fields": [
										{
											"id": "blSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the IP/domain(s)."
										},
										{
											"id": "blTargets",
											"title": "IP Address(es) / Domain(s)",
											"type": "textarea",
											"value": "",
											"caption": "IP address(es) or domain(s) to check. Separate multiple with commas or newlines (max 10)."
										},
										{
											"id": "blDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										}
									]
								},
								{
									"id": "smtpChecker",
									"title": "SMTP Checker",
									"description": "Test SMTP server connectivity, STARTTLS, authentication, and send test emails.",
									"fields": [
										{
											"id": "smtpSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the SMTP server(s)."
										},
										{
											"id": "smtpServers",
											"title": "SMTP Server(s)",
											"type": "textarea",
											"value": "",
											"caption": "SMTP server hostname(s) or IP(s). Separate multiple with commas or newlines (max 10)."
										},
										{
											"id": "smtpDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										},
										{
											"id": "smtpPort",
											"title": "Port",
											"type": "text",
											"value": 25,
											"variant": "number",
											"caption": "SMTP port (25, 465, 587)."
										},
										{
											"id": "smtpTestRelayAddress",
											"title": "Open Relay Test Address",
											"type": "text",
											"value": "",
											"caption": "Email address to use for open relay test (leave empty to skip)."
										},
										{
											"id": "smtpSendTest",
											"title": "Send Test Email",
											"type": "checkbox",
											"value": false,
											"caption": "Enable to send a test email through the server."
										},
										{
											"id": "smtpTestFrom",
											"title": "Test Email From",
											"type": "text",
											"value": "",
											"caption": "Sender email address for test email."
										},
										{
											"id": "smtpTestTo",
											"title": "Test Email To",
											"type": "text",
											"value": "",
											"caption": "Recipient email address for test email."
										},
										{
											"id": "smtpAuthUser",
											"title": "SMTP Username",
											"type": "text",
											"value": "",
											"caption": "Username for SMTP authentication (optional)."
										},
										{
											"id": "smtpAuthPass",
											"title": "SMTP Password",
											"type": "text",
											"value": "",
											"caption": "Password for SMTP authentication (optional)."
										}
									]
								},
								{
									"id": "bandwidthTest",
									"title": "Bandwidth/Speed Test",
									"description": "Test network bandwidth using Cloudflare Speed Test or a custom URL.",
									"fields": [
										{
											"id": "bwMode",
											"title": "Mode",
											"type": "select",
											"value": "Cloudflare Speed Test [cloudflare], Custom URL [custom]",
											"caption": "Select the speed test mode."
										},
										{
											"id": "bwCustomUrl",
											"title": "Custom URL",
											"type": "text",
											"value": "",
											"caption": "Custom URL for download test (when mode is 'custom'). Use a large file for accurate results."
										},
										{
											"id": "bwTestSize",
											"title": "Test Size",
											"type": "select",
											"value": "Small (1 MB) [small], Medium (10 MB) [medium], Large (25 MB) [large]",
											"caption": "Size of data to download for the speed test."
										}
									]
								},
								{
									"id": "portListener",
									"title": "TCP/UDP Listener",
									"description": "Open a TCP or UDP port and listen for incoming connections/data.",
									"fields": [
										{
											"id": "listenerProtocol",
											"title": "Protocol",
											"type": "select",
											"value": "TCP [TCP], UDP [UDP]",
											"caption": "Protocol to listen on."
										},
										{
											"id": "listenerPort",
											"title": "Port",
											"type": "text",
											"value": 8080,
											"variant": "number",
											"caption": "Port number to listen on (1-65535)."
										},
										{
											"id": "listenerTimeout",
											"title": "Listen Duration (seconds)",
											"type": "text",
											"value": 60,
											"variant": "number",
											"caption": "How long to listen for connections (5-300 seconds)."
										},
										{
											"id": "listenerMaxConn",
											"title": "Max Connections",
											"type": "text",
											"value": 10,
											"variant": "number",
											"caption": "Maximum number of connections to accept before stopping."
										}
									]
								},
								{
									"id": "websocketTester",
									"title": "WebSocket Tester",
									"description": "Test WebSocket connections: connect, send messages, and receive responses.",
									"fields": [
										{
											"id": "wsUrl",
											"title": "WebSocket URL",
											"type": "text",
											"value": "",
											"caption": "WebSocket URL (ws:// or wss://)."
										},
										{
											"id": "wsSendMessage",
											"title": "Message to Send",
											"type": "textarea",
											"value": "",
											"caption": "Message to send after connecting (optional)."
										},
										{
											"id": "wsTimeout",
											"title": "Timeout (seconds)",
											"type": "text",
											"value": 10,
											"variant": "number",
											"caption": "Connection timeout in seconds."
										}
									]
								},
								{
									"id": "apiHealthMonitor",
									"title": "API Health Monitor",
									"description": "Monitor API endpoints: check status codes and optionally validate JSON responses.",
									"fields": [
										{
											"id": "apiSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the endpoint(s)."
										},
										{
											"id": "apiEndpoints",
											"title": "API Endpoint(s)",
											"type": "textarea",
											"value": "",
											"caption": "API URL(s) to monitor. Separate multiple with commas or newlines (max 20)."
										},
										{
											"id": "apiDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										},
										{
											"id": "apiExpectedStatus",
											"title": "Expected Status Code(s)",
											"type": "text",
											"value": "200",
											"caption": "Expected HTTP status code(s), comma-separated (e.g., 200,201)."
										},
										{
											"id": "apiTimeout",
											"title": "Timeout (seconds)",
											"type": "text",
											"value": 10,
											"variant": "number",
											"caption": "Request timeout in seconds."
										},
										{
											"id": "apiValidateJson",
											"title": "JSON Validation",
											"type": "textarea",
											"value": "",
											"caption": "Optional JSON validation rules. Format: 'field=value' or 'field' (existence check). Separate multiple with semicolons."
										}
									]
								},
								{
									"id": "snmpQuery",
									"title": "SNMP Query",
									"description": "Query SNMP-enabled devices using SNMPv1, v2c, or v3.",
									"fields": [
										{
											"id": "snmpSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the host(s)."
										},
										{
											"id": "snmpHosts",
											"title": "Host(s)",
											"type": "textarea",
											"value": "",
											"caption": "SNMP host(s) to query. Separate multiple with commas or newlines (max 10)."
										},
										{
											"id": "snmpDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										},
										{
											"id": "snmpVersion",
											"title": "SNMP Version",
											"type": "select",
											"value": "v1 [v1], v2c [v2c], v3 [v3]",
											"caption": "SNMP protocol version."
										},
										{
											"id": "snmpCommunity",
											"title": "Community String",
											"type": "text",
											"value": "public",
											"caption": "SNMP community string (for v1/v2c)."
										},
										{
											"id": "snmpPort",
											"title": "Port",
											"type": "text",
											"value": 161,
											"variant": "number",
											"caption": "SNMP port (default: 161)."
										},
										{
											"id": "snmpTimeout",
											"title": "Timeout (ms)",
											"type": "text",
											"value": 5000,
											"variant": "number",
											"caption": "Query timeout in milliseconds."
										},
										{
											"id": "snmpCustomOids",
											"title": "Custom OIDs",
											"type": "textarea",
											"value": "",
											"caption": "Additional OIDs to query. Format: 'name=1.3.6.1...' or just the OID. Separate with commas or newlines."
										},
										{
											"id": "snmpV3User",
											"title": "SNMPv3 Username",
											"type": "text",
											"value": "",
											"caption": "Username for SNMPv3 authentication."
										},
										{
											"id": "snmpV3AuthProto",
											"title": "SNMPv3 Auth Protocol",
											"type": "select",
											"value": "SHA [SHA], MD5 [MD5]",
											"caption": "Authentication protocol for SNMPv3."
										},
										{
											"id": "snmpV3AuthPass",
											"title": "SNMPv3 Auth Password",
											"type": "text",
											"value": "",
											"caption": "Authentication password for SNMPv3."
										},
										{
											"id": "snmpV3PrivProto",
											"title": "SNMPv3 Privacy Protocol",
											"type": "select",
											"value": "AES [AES], DES [DES]",
											"caption": "Privacy/encryption protocol for SNMPv3."
										},
										{
											"id": "snmpV3PrivPass",
											"title": "SNMPv3 Privacy Password",
											"type": "text",
											"value": "",
											"caption": "Privacy/encryption password for SNMPv3."
										}
									]
								},
								{
									"id": "ldapTest",
									"title": "LDAP/AD Test",
									"description": "Test LDAP/Active Directory connectivity, authentication, and search queries.",
									"fields": [
										{
											"id": "ldapSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the LDAP server(s)."
										},
										{
											"id": "ldapServers",
											"title": "LDAP Server(s)",
											"type": "textarea",
											"value": "",
											"caption": "LDAP server hostname(s) or IP(s). Separate multiple with commas or newlines (max 10)."
										},
										{
											"id": "ldapDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										},
										{
											"id": "ldapPort",
											"title": "Port",
											"type": "text",
											"value": 389,
											"variant": "number",
											"caption": "LDAP port (389 for LDAP, 636 for LDAPS)."
										},
										{
											"id": "ldapUseSsl",
											"title": "Use SSL/TLS",
											"type": "checkbox",
											"value": false,
											"caption": "Enable SSL/TLS (LDAPS). Automatically changes port to 636 if checked."
										},
										{
											"id": "ldapBindDn",
											"title": "Bind DN (Username)",
											"type": "text",
											"value": "",
											"caption": "Bind DN for authentication. Leave empty for anonymous bind."
										},
										{
											"id": "ldapBindPassword",
											"title": "Bind Password",
											"type": "text",
											"value": "",
											"caption": "Password for LDAP authentication."
										},
										{
											"id": "ldapBaseDn",
											"title": "Base DN",
											"type": "text",
											"value": "",
											"caption": "Base DN for search operations (e.g., DC=example,DC=com). Leave empty to skip search."
										},
										{
											"id": "ldapSearchFilter",
											"title": "Search Filter",
											"type": "text",
											"value": "(objectClass=*)",
											"caption": "LDAP search filter."
										},
										{
											"id": "ldapSearchScope",
											"title": "Search Scope",
											"type": "select",
											"value": "Base [base], One Level [one], Subtree [sub]",
											"caption": "LDAP search scope."
										}
									]
								}
							]
						}
					}
				],
				"notes": "",
				"icon": "check-network-outline",
				"uid": "",
				"gid": "",
				"kill": "none",
				"runner": false
			}
		}
	]
}
